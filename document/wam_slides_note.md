## wam-slides概要

### 基本的事項
- WAMでは、通常我々が prolog に対してイメージしている動作とは真反対の動作をすると言ってよい
①最初に、Queryを(レジスタなどに）格納する
②それに対して、データ(ファクトや述語)をパターンマッチしてみて、マッチしたら、成功する。（Heap上のデータに対してパターンマッチするのではなく、Queryに対してデータをパターンマッチする）
・・・この動作が腑に落ちていなかったので、長らくWAMの動作を理解することが難しかった。
（通常我々が prolog に対してイメージする動作とは、まず最初にデータが格納・登録されており、それに対して Query をマッチさせるイメージと思う）

読み進めると、L1あたりで、通常のPrologの処理に近くなってゆき、以下のように解釈するのがよさそうと感じた
- Queryの読み込み処理とは、述語をcallするための前処理として、レジスタやHEAPに初期値（および変数）を準備する処理と考えてよく、その直後に、callが呼ばれる（Queryで設定した述語がcallされる）
・述語はCODEエリアに事前に格納されており、callされると、そこから呼び出され、前記準備された初期値に対してパターンマッチ処理を実施して
　ゆく。、、、と考えると、よりすんなり理解できると考える。

##### Dereference:
  理解していたはずだが、すっかり忘れていたので・・・
  たぶん、一度ユニファイしたが、最終的に失敗したときに、変数などを参照（リファレンス）したものを
  すべて解消する(でリファレンス)することを指すのであろう。。。
  ====> 全然全くちがった！！
  Dereferencing: (訳語) 逆参照
    与えられたアドレス値から、チェインを逆にたどって、最終的な値まで辿った上で、
    その最終的な結果としてアドレスを返すこと
    （その結果は具体的な値を指す場合もあるが、未だ参照先が確定していない変数状態の場合もある）
    Prologではあらゆる場面でよく見かける処理。


### 【wam-slides.pdfで定義されている言語族のリスト】
L0
  - 言語上の基本定義に限定(変数、ファンクタ、定数のみ）
  - HEAP領域を定義
  - ユニファイを実装
  - デリファレンスを実装  
	例: 定義された述語 f(a,b,c). に対する問い合わせ ?-f(X,Y,Z).

L1  
  - L1は一見すると、さほどの変更がなされていないように見えるが、コード最適化や、連言表記のための布石(SP)など、実際は
　　prolog言語完成に向けた、多くの改造がなされている、一種の転換点の言語セットのように見える
  - L0部分はそのまま
  - CODEエリアが新設
  - AレジスタとXレジスタを区別する
  - callが登場
  - SPが新設

L2  
  - L1部分はほぼそのまま
  - ルール(a:-b,c.形式)が定義可能になり、ヘッド部とボディ部が表現できるように
  - ボディ部は、連言表記(b,c,dなど)により、複数のアトムの論理積を表現可能に
  - CPが新設
  - permanent/temporary 変数が登場
  - Eが新設され、STACKが登場

L3  
  - Pure prologの言語族
  - 同じ述語を複数定義(disjunctive definitions)可能にし、Backtrackが発生するように
  - SLD導出
  - Environment STACK(=AND-STACK)
  - Choice point STACK(=OR-STACK)
  - Bが新設(=Backtrack Register)
  - TRAIL登場
  - TRが新設(=Trail Register)
  - HBが新設(=HEAP Backtrack  Register)
  - try_me_else/retry_me_else/trust_me が登場

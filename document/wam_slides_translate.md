(This translation is created for studying basic idea of WAM)

# Warran's Abstract Machine
#### A Tutorial Reconstruction
#### Hassan Ait-Kaci

### はじめに
  WAMは1983に David H.D.Warren により考案されたものである。  
  しかし、ごく最近に至るまで、それがどのような仕組みで動作するのか、明確な解説がなされてこなかった。  

本書では  
- 最も単純な定義をもとに、WAM仮想マシンの設計を行う。そしてこれを段階的に拡張してゆく。  
- (全ての)設計上の特徴について、根拠を示しながら完全な解説を行う。  


【目次】
1. ユニフィケーション
2. フラット・レゾリューション
3. 純粋Prolog
4. 最適化  

　　　
## 1. ユニフィケーション(Unification—Pure and Simple:)

　＜識別子の定義＞  
### 【一階述語論理の項(First-order term)】
(prologで使用する)一階述語論理の項について、以下に定義する。
* 変数記号: 大文字で始まるアルファベット列で表す。
* 定数記号: 小文字で始まるアルファベット列で表す。
* 構造体(structure):  
f(t1,t2,t3...)の形式で表す。  
なお 'f' はファンクタ(関手)と呼ばれる(一種の)シンボルである。  
また t1,t2,t3... は一階述語論理の項とする `(例:f(X),f(a,g(X,h(Y),Y),g(X))...)。`

  'f/n'と表記した場合 シンボルが f、 アリティが n のファンクタを意味する。（アリティとは 項の個数のこと）
  定数cは 構造体の特別なケースとし、ファンクタc/0 と等価とする。

```
訳註:wikipediaより抜粋
一階述語論理の項 (term) は次のように帰納的に定義される：
 1. 変数と定数記号はすべて項である。
 2. t1,...,tn が項で、f がアリティ n の関数記号ならば、f t1,...,tn は項である。
 3. 上記の 1. と 2. によって項とされるものだけが項である。
```

### 【L0言語定義:Language L0】
#### 構文(Syntax)
- 't'   :プログラムの構文
- '?-t' :クエリの構文

ここで t とは、(それ自体は)変数ではない、一階述語論理の項である。  
(なお(項の中で変数が現れることは許されるが)変数のスコープは、プログラム(やクエリ)の項内に限定される。)

#### 構文の意味(Semantics)
プログラム p と クエリ ?-q の MGU(most general unifier:最大汎用単一子)を導出する（訳註:これをユニファイという）。
- p と q がユニファイできない場合は実行が失敗する。
- ユニファイできれば成功とし、クエリ q 中に変数がある場合は、バインドした結果を取得する。

なおL0では、処理が失敗となった場合は 以降の処理を中断する。



### 【仮想マシン M0 】
項に対するHEAP上の表現(Heap representation of terms):
- 仮想マシンM0は（項を内部的に表現(保存)するために）HEAPと呼ばれるグローバル格納領域を使用する。
- HEAPは通常、メモリ上のデータセルの配列として実装される。

#### HEAP上の表現例: p(Z,h(Z,W),f(W))
```
 0|STR|1|
 1| h/2 |
 2|REF|2|
 3|REF|3|
 4|STR|5|
 5| f/1 |
 6|REF|3|
 7|STR|8|
 8| p/3 |
 9|REF|2|
10|STR|1|
11|STR|5|

(アドレス 7 を起点とする)
```

```
訳注：  
項(term)の階層構造を、(計算機で取扱いが容易な)配列形式に変換している。  
配列上で階層関係を表現するため、ポインタでメモリアドレスとの関連づけを行い、
ポインタを参照すると、データ型とデータ長（＝要素の数）が判別できるようになっている。
（各データは、配列で格納する関係上、固定バイト長のデータで取り扱う必要がある。

一方で、データ構造自体は、配列の格納領域が許す限り自由な構造を格納でき、事実上制約が無い。
ただし、格納する時点で、保存するデータ長が判明していなければならないという保存上での制約はあろう。）
（個人的疑問: 10 は、STR|0|にならないのか？ 11は STR|4| にならないのか？そうしないと、
　「アドレス7を起点とする」という表記と整合性が合わないのではないか？
・・・自己解決 4|STR|5| の表記と、 11|STR|5| の表記は、いずれも、5| f/1 | を指しており、両者は同格であるとすると、
全く整合する表記と言えそうだ(起点となるアドレスが、4および11、というように複数存在しえると言い換えるといいだろうか)。
4|STR|5| の存在意義がいまひとつピンとこない、単なるセパレータのようなものに見えてくる、
省略したら不都合があるのだろうかと感じる者もいるだろうが、実は後に最適化により取り除かれるので、やはり冗長な表現であると言える。
初期段階の説明のために導入されていると考えて良いようだ。）
```

### 【ヒープ領域上のデータセルについて】
- 変数セル(variable cell):  
  <REF,k> で表す (kは格納アドレス(=HEAPのインデックス)である)
- 構造体セル(structure cell):  
  <STR,k> で表す (kはファンクタセルの格納アドレスである)
- ファンクタセル(functor cell):  
  ファンクタ表記をそのまま格納する(タグは省略)

### 【その他の約束事(Convention)】
- アドレス k に格納された、未束縛(unbound)の変数の場合は <REF,k>とする (つまり自分自身の格納アドレスを指す)。  
- 構造体 f(t1,...,tn)の場合、(合算すると) n+2 個のHEAPセルを消費する。  
  （+2となるのは、STRセルとファンクタセルが 追加で消費されるため）  
- f(t1,...,tn)の最初のセルは <STR,k> であるが、ここで k は ファンクタセル('f/n'が格納されている)の格納アドレスを指す。  
   (隣接セルでない場合もある:前例の 11番目のセル などがその例)  
- ファンクタセルは、必ず、直後のn個の隣接セルが続いて格納される。  
    例えば HEAP[k] = f/n であれば、HEAP[k+1]は t1に割当てられ、HEAP[k+n]はtnに割り当てられる。  

### 【L0言語クエリのコンパイル(Compiling L0 queries)】
解くべき方程式の一方(つまりquery側)の準備をする。  
(元は単なるテキストである)クエリ項 ?- q を翻訳して、一連の命令シーケンスに変換する。  
この一連の命令シーケンスは、(これを実行すると）HEAP上に q のための形式的なデータ構造を構築(格納)するようにデザインされている。  

### 【変数レジスタ(Variable registers)】
変数レジスタ X1,X2,..., は、HEAPデータセル上に項(term)のデータ構造を格納する際の、一時的な記憶場所として使用される。  
それら変数レジスタは各項(term)に割り当てられ、また各サブターム(Sub Term)に対しても、それぞれ1つずつ割り当てられる。

### 【その他の約束事(Convention)】
- 変数レジスタは、利用可能なインデックスのうち、最小の番号のものから割当てられる。
- (このため)レジスタ X1 は、(結果的に)必ず、最も外側の項に割り当てられる。
- 同じ変数には同一のレジスタが割り当てられる。
```
  たとえば、項 p(Z,h(Z,W),f(W)) に対して割り当てられる、レジスタの内容を例示すると以下となる。
  X1=p(X2,X3,X4)  :最も外側の項
  X2=Z            :変数Zに割り当てられる変数レジスタは、直近の使用可能なインデックス(index=2) 番号のレジスタから選ばれる
  X3=h(X2,X5)     :複数出現した変数(Z)は同一のレジスタ(X2)が割り当てられる
  X4=f(X5)        :変数(W)も同様である(X5)
  X5=W.
```
```
（疑問・・・ X5=Wが一番最後のインデックスになっているのがピンとこない。
だが、それぞれの項の内部の変数は後続のレジスタ番号が指定されているので、動的に組み立てる
のであれば、一度書き直しをしなければならないし、予め上記のような指定をコーディングされる
ものを読み込むのであれば、見た目上の順序はあまり問題ではなく、ただ整合していればよい
ということにはなる。）

(訳註:
上記変数割当ては、横型探索のような動きにみえる、上記の例だと・・・
最上位階層:p()
次の階層: Z,h(),f()
最下位層: Z:2回目,W,W:2回目
という風に序列されるとみればよいかもしれない
  - 変数Zが変数の中で最初、次にZ:2回目、次にW、次にW(2回目)の順で変数割当てを調整するとみる
・・・しかし、このような横型探索のような動きは、実装上は面倒な気がしてくる・・・
そもそもこの表記自体は、あくまでも論理的なものであると捉えられるのかもしれないし、別の方法で実装しても
よいような気がするし、、、まだよく分からないところがある。
)（一番ひっかかるのは、X3あたりでX5を指定しているが、この段階で、どうやってX5を予測できたのか？その時点では、
変数のインデックスの位置が一見決められないように思えてしまうこところである。
・・・ただ、X1を決めた時点で、サブタームが X2,3,4と生み出されるので、次に変数を設定すると、X5にならざるを得ない
というふうにみると、納得できるのかもしれない・・・）
```

### 【フラット形式（Flattened form）】
(訳註: prolog は項(term)内で複雑な構造を表現できるが、これを仮想マシン上の機械的処理が容易となるように、
構造（つまり木構造）を「フラット」（つまり一直線の列）に変換する必要がある。)

いかなる項(term)も、以下の連言式の集合と等価である  
```
Xi=X 又は Xi=f(Xi1,...,Xin),(n >= 0)  
```
(ただし Xiは すべて区別可能な(新規※の)変数名とする)。  

```
    (※:重複がない・使い回しがない という意味と理解)

    　・外部(で指定された)変数名は保持する意味がない
        (訳註:つまり、Zやwの名前そのものを保持することは意味がなく、X2や,X5で言い表せているので、
        　X2=Z や、X5=Wはそもそも必要ない、の意か)
      ・クエリ項のフラット形式(flattened form)は、
        以下のような一連のレジスタ割り当てに相当する。
          Xi = f(Xi1,...,Xin)
        レジスタ割当の順序は「ボトムアップ」の順とする(つまり、レジスタは、
```
そのレジスタが、サブ項の引数として使用されるよりも「前に」割り当てられる)。
```
        (訳注: p(Z,h(Z,W),f(W))のような場合に、サブ項であるh(Z,W)のレジスタX3が
        p(X2,X3,X4)で使用されるより「前に」割り当たっているように調整することと理解)
        (ちなみに、さらにh(Z,W)の変数X2,X5については、サブ項としてh(Z,W)を格納する際に
        合わせて割当たっていると考える。
        変数名そのもの代入式は前述のルールにより除外されたことで、コードを追うのが難しくなるが、最適化の一環であろう。)
```
  フラット形式におけるクエリ項の例 p(Z,h(Z,W),f(W))は以下:  
    X3=h(X2,X5),X4=f(X5),X1=p(X2,X3,X4)
```
   （訳注:サブ項の定義が順番として先にくるように、インストラクションの順番がボトムアップに調整されている。
    　ただし、変数レジスタのインデックスがそれによって入れ替わったりはしていない。
    　・つまり、まずここで問題となるのは、データ代入に関する、手順上の「順序」であり（つまり命令の実行順であり）
    　これが維持できなければ、中身の値の整合性が保証できなくなる。
    　・一方で変数レジスタの番号は(そのことに影響されることなく)トップダウンで参照され、かつ最小限のリソースとなるように
    　（使用する変数レジスタの番号の最大値が最小になるように）調整することが可能なので、それによってレジスタ付番の
    　オーダーを決めているということができそうである。）
    (少なくともX1が一番外側の項を割り当てているという点は維持される必要がある:後のユニファイ処理のために)

	（考察: これを実現するためには、まず、構文解析木？を作ったうえで、その木構造を、縦型探索の方式で、
　　　　　 ルートから下へ、左から右へ順次進み、リーフノードに突き当たったものから順番に、レジスタに割り当てるようにしたら、
		     所定の動作をさせることができるのではないか？その時に、木構造のルート側のレジスタ割り当てが、
         全ての下位構造の割当が終わった後に、一番最後に割り当て処理をするようにすればよい、ということではないだろうか）
```

### 【トークナイズド形式（Tokenized form）】
フラット化(Flattend)したクエリ項を左から右に読み込むことで、
クエリ項 Xi=f(Xi1,...,Xin) はトークナイズされ、
Xi=f/n,Xi1,...,Xin のようなシーケンスに変換される。

トークナイズされたクエリ項 p(Z,h(Z,W),f(W))は、
以下のような、9つのトークンに変換される。
```
    1: X3 = h/2,（訳注: 原文ではh/3だが、明らかに間違いと考え訂正）
    2: X2,
    3: X5,
    4: X4 = f/1,
    5: X5,
    6: X1 = p/3,
    7: X2,
    8: X3,
    9: X4.
    (訳注: 順番は、フラット形式と同じ。その上で、ファンクタ表記に変換されたり、引数部分が
    単に変数の列挙に変換されたりしている。HEAPに格納することを念頭に置いた表記であろう。)
```
    。。。ここから実際の命令列に変換してゆく。。。

（トークナイズの結果）処理プロセスのための３種類のトークンに（分類できる）。
1. 構造体ファンクタに割り付けられた、レジスタ
2. 読み込みストリーム中、(その時点で)初めて登場する、レジスタ引数
3. 読み込みストリーム中、既に登場したことのある、レジスタ引数

### 【M0 クエリ命令: M0 query term instructions】
前記3種類のトークンは、それぞれ3つの異なる処理に対応する
1. put_structure f/n,Xi
 - HEAPに、新規の STR セルを PUSHし、
 - そのセルを、割り当てられたレジスタにコピーする
2. set_variable Xi
 - HEAPに、新しい REF セルを PUSH(まだ未参照なので、値はそのセルのアドレス自身を格納)し、
 - そのセルを、割り当てられたレジスタにコピーする(つまり HEAPの値→レジスタ へコピー)
3. set_value Xi
 - HEAPに、新しいセルを PUSHし、
 - そこに、レジスタの値をコピーする（つまり レジスタの値→HEAP へコピー）

### 【HEAPレジスタ: H】
H は HEAP領域中、次に参照される予定である、空セルのアドレスを記憶する。

＜各マシンコードの擬似コード＞
```
  put_structure f/n,Xi ≡　HEAP[H] ← <STR,H+1>;
                          HEAP[H+1] ← f/n;
                          Xi ← HEAP[H];
                          H ← H + 2;

  set_variable Xi      ≡ HEAP[H] ← <REF,H>;
                         Xi ← HEAP[H]
                         H ← H + 1;

  set_value Xi         ≡ HEAP[H] ← Xi;
                         H ← H + 1;
```
```
  (L0言語クエリ 「?-p(Z,h(Z,W),f(W))」のM0仮想マシンコード)
  put_structure h/2,x3
  set_variable X2
  set_variable X5
  put_structure f/1,x4
  set_value X5
  put_structure p/3,x1
  set_value X2
  set_value X3
  set_value X4
```
```
  (前述のトークナイズ形式を素直に命令列に変換している。
  変数が２度目に現れる場合に、トークン種別が変わる（それにより set_value を使用できる）
  ので、トークナイズ時に(トークン種別を判別する)工夫（変数が既に出現したかどうかを記憶するなど）が必要であろう)

 （気づき: なるほど！ レジスタは一番外側の項がX1に割りあたるような順(トップダウンの順かな？)でセットしたいが
  HEAP上では、ボトムアップに、一番外側の項が、最後尾の領域に記憶されるようにしたいのかな？
  そうすれば、(ボトムアップな順番に記録することになるから）HEAP上の参照関係の記録順序が、間違いなく維持されるから
  参照すべき記憶領域が、まだ存在しない、という事態が回避できるからね。）

  (HEAP上で、木構造のデータの一種である一階述語論理の項を格納するためには、木構造の末端(leaf)から順次格納するように
　つまり、ボトムアップに、組み立てていかないと、参照関係を適切に維持するのが、難しくなるのかな？
　例えば、一番外側の項を格納する段階で、木構造上の子要素が、すべて既に格納され、木構造上の親からみて全て参照できるように
　HEAP上のアドレスが確定していることが望ましいし、効率もよいだろう：そうでないと、一度その要素がどの格納領域のアドレス
　に格納されるべきか、計算した上でないと格納できないか、場当たり的な中継記憶領域を設けて辻妻を合わせるしかなくなるだろう
　(まあ、コンパイル時に決めることができる事項であり、かつてのようにコンパイル時のメモリ効率を追求する要件はかなり緩和されているので
　この格納構造以外の方法も考案できるだろう。将来的な都合で変更も可能な事項と考える。)
  )
```
```
<<<< このコマンドを実行した結果HEAP上にどう記録されるか、実際に机上計算してみよう。
   0|STR|1|_
   1| h/2 |
   2|REF|2|
   3|REF|3|
   4|STR|5|_
   5| f/1 |
   6|REF|3|
   7|STR|8|_
   8| p/3 |
   9|REF|2|
  10|STR|1|
  11|STR|5|
ああ、冒頭のHeapの例と全く同じになるのか・・・
レジスタの値も書いてみると・・・
X3 = <STR,1>
X2 = <REF,2>
X5 = <REF,3>
X4 = <STR,5>
X1 = <STR,8>
・・・たしかに、Heapのデータの構築のために、レジスタを利用したんだな、ということがわかってくる。
たとえば、set_vale X4 では、レジスタの値を使って、 11|STR|5| がセットされることがわかる。
>>>>
```


### 【L0 プログラムのコンパイル】
`(訳注:どうして queryを読み込んだ「後」にプログラムの話しを展開しているか？
それは、未だ CODE_AREA が用意されていないからであろう。CODE_AREAは L1で用意される。)`

プログラム項 p をコンパイルするとき、以下の前提を置いている。  
  ・クエリ ?- q が(あらかじめ)HEAP上にビルドされ、レジスタ X1 にそのアドレスが格納されている  
 ```
  (訳注: ・・・X1 にアドレスを格納していることが、明確にプログラム側の足掛かりになっている。）
  (もう１点指摘すると、X1には一番外側の項が割り当てられるが、一番外側の項だけは、項の数が確実に一致する前提に立てる。
  　そこから先のサブタームになると、見た目の項の数が必ずしも一致するわけではない(単一の変数である場合もあれば、
  　サブタームとして複数の項が付属する場合もあるだろう)。だからX1にだけ成立する条件と言えよう。)
```
このため、L0プログラム項のためのコードについて2つのモードを使用する:
- READモードは、HEAP上のデータに対するマッチのために使用される
- WRITEモードは、クエリ項とまったく同じように、項をHEAP上にビルドするために使用される
    `（訳注: 変数を作成するために使用される）`

p へのコードは以下からなる:  
- レジスタX1にすでに格納されている、項構造について(つまりqの項構造について)、pの構造体としてのファンクタをできるかぎりマッチさせる。
- HEAP中にあるクエリ項 ？-q の中に、未束縛のREFセルが見つかった場合、
p の対応する部分項を(qに紐づける)（いわゆるパターンマッチの）適用例(exemplar)として、HEAP上に新規に項を作り、これをバインドする。

### 【Tokenizing L0 program terms】
変数レジスタは、先程と同じように割り当てられているとする。  
例えば、 プログラム項 p(f(X),h(Y,f(a)),Y); の場合は以下のようになる  
```
    X1 = p(X2,X3,X4)
    X2 = f(X5)
    X3 = h(X4,X6)
    X4 = Y
    X5 = X
    X6 = f(X7)
    X7 = a.
```
```
>>>>>(対比のために、先の記載を再掲載)　p(Z,h(Z,W),f(W))
    X1 = p(X2,X3,X4)  :最も外側の項
    X2 = Z            :変数Zに割り当てられる変数レジスタは、直近の使用可能なインデックス(index=2) 番号のレジスタから選ばれる
    X3 = h(X2,X5)     :複数出現した変数(W)は同一のレジスタ(X5)が割り当てられる
    X4 = f(X5)        :同上
    X5 = W.
    このように対比してみると、X1は(変数も対応させることができるので)対比可能だが、
    それ以降はそれぞれの構造の違いが出てくるのでレジスタの対応関係は異なってくる。
    （ただ、Query側は、HEAPに記録されているのだから、レジスタのレベルで対比できなくても困らないと考える）
<<<<
```
しかしながら、今回(プログラム)は、フラット化フォームは、(クエリのフラット化フォームと異なり)トップダウンの順とする。  
なぜならば、HEAP上のクエリデータは、あらかじめ利用可能と想定されているからである。  
（たとえ、関連づけられていない(unbound) REF セルのみがフォームに存在していたとしても、である）

最終的に、プログラム項 p(f(X),h(Y,f(a)),Y)は、以下のようにフラット化される:
```
  X1 = p(X2,X3,X4),
  X2 = f(X5),
  X3 = h(X4,X6),
  X6 = f(X7),
  X7 = a.
```
なお、次工程のトークナイズは、前述と全く同様である。



### 【 M0 プログラム命令(M0 query term instructions)】

プログラムトークンは、3種類のマシン命令からなる
1. get_structure f/n,Xi
2. unify_variable Xi
3. unify_value Xi

以下のいずれかの状況に対応する:　　
1. 構造ファンクタに関連づけられるレジスタ引数
2. 最初に登場するレジスタ引数
3. 既に登場したことのあるレジスタ引数

```
L0プログラム「p(f(X),h(Y,f(a)),Y).」の仮想マシンM0のマシンコード
  get_structure p/3,x1
  unify_variable x2
  unify_variable x3
  unify_variable x4
  get_structure f/1,x2
  unify_variable x5
  get_structure h/2,x3
  unify_value x4
  unify_variable x6
  get_structure f/1,x6
  unify_variable x7
  get_structure a/0,x7
```
```
(考察：先のクエリの場合は、ボトムアップに命令が組み立てられていた（最初は、h/2 の格納から始まり〜p/3の格納で終わる）
　　   プログラムの場合は、トップダウンに命令が組み立てられている
      これは、実際のユニファイが実行される順番を示しているので、トップダウンになるのが至当と考える）
(むしろ、トップダウンに呼び出されることを想定しつつも、HEAP上に構造データを効率よく格納するために、ボトムアップ
にセル上に格納する方式を編み出したのが、極めて素晴らしいのではないだろうか・・・)
(追記: プログラムコードは、実際には、コンパイル後直ちに順に実行されるものであり、
HEAPに格納するためのものでないので、むしろ、トップダウンに実行できる必要があるということか。
（呼ばれる側はボトムアップに格納され、呼ぶ側はトップダウンに実行される。これでぴったり合うということか
　・・・これは次のL1でプログラムを格納するエリアである CODE_AREA が登場するので、そもそも格納域の役割分担の
　　　　話しであり、HEAPの役割は、あくまでもクエリのデータ格納域+ユニフィケーションを実行するパターンマッチ
　　　　のための領域であり、さらに実行結果の結果を格納し、これを読み込む解答のための領域であるとみなすべきだろう)）
```

```
--
(対比のために先ほどの記述を再掲載)
<<<< このコマンドを実行した結果HEAP上にどう記録されるか、構成してみるのもよいであろう。
p(Z,h(Z,W),f(W))
   0|STR|1|
   1| h/2 |
   2|REF|2|Z
   3|REF|3|W
   4|STR|5|
   5| f/1 |
   6|REF|3|W
   7|STR|8|
   8| p/3 |
   9|REF|2|Z
  10|STR|1|
  11|STR|5|
ああ、冒頭のHeapの例と全く同じになるのか・・・
レジスタの値も書いてみると・・・
x1 = <STR,8>
x2 = <REF,2>
x3 = <STR,1>
x4 = <STR,5>
x5 = <REF,3>
>>>>
【コメント: 以下の動作の詳細な定義は、この後の本文記述で説明されているので、説明内容が不明でも心配しなくていい】
p(Z=f(X),h(Z=f(X),W),f(W))
p(f(X),h(Y,f(a)),Y)
(Heapポインタは H=12 にセットされているとする)
get_structure p/3,x1    |  deref(x1) => <STR,8>, HEAP[8] == p/3, S = 9, mode = READ
unify_variable x2       |  x2 = HEAP[9]  =<REF,2>, S = 10　（これって、各レジスタに q の第1〜3引数を再ロードしている動きだね）:Z
unify_variable x3       |  x3 = HEAP[10] =<STR,1>, S = 11　（同上）:h(Z,W)
unify_variable x4       |  x4 = HEAP[11] =<STR,5>, S = 12　（同上）:f(W) (あっ、単なる再ロードではなく、事実上 Yとユニファイされているということなのか。。。 Y=f(W)ただ、やっていることは再ロードでしかない。。。巧妙？ということか？ X4は、はなからYとみなしているが、再ロードの動作により、Y=f(W)と同じとみなせるのか？f(W)のことははなから気にしていなくて、X4はYだ、とコンパイルしているということか）
get_structure f/1,x2    |  <REF,2> = deref(x2), STORE[2]==<REF,_>, HEAP[12] =<STR,13>, HEAP[13]=f/1, bind(2,12)...なので、x2=<STR,13>かな, H=14, mode = WRITE
unify_variable x5       |  HEAP[14] =<REF,14>, x5= HEAP[14] =<REF,14>, H=15, S=4 (#注 qではx5は変数Wがセットされていたが、上書されて変数Xがセットされている（大丈夫か？）（大丈夫。そもそも x1 しか内容保証していないと言える。それでも、上記再ロードでqの引数は辿れるようになっている。Wは、この時点では、明示的にはレジスタにセットされていないということかな？）)
get_structure h/2,x3    |  <STR,a=1> = deref(X3), HEAP[a=1]==h/2,  S = a+1=2, mode = READ (h/2 のユニファイが成功し、h/2の各項(subterm)のマッチングへと下降してゆく)

p(f(X),h(f(X),W),f(W))
p(f(X),h(Y=f(W),f(a)),Y=f(W))
　　　　　　　　　　　　　　　　# X4(=f(W))を、S=2(=f(X))とユニファイする
unify_value x4          |  unify(X4,S=2) #注 S=2 は、HEAP上のaddress=2 を差し もともと 2|REF|2|Z であったが bind(2,12)で上書きされ、<STR,13> =f(X) に差し替えられている
                           --> unify(<STR,5>,<STR,13>) --> (f/1 == f/1 となったので・・・）unify(<REF,3>,<REF,14>)
                           --> ・・・bind(3,14) つまりbind(W,X))かな で、HEAP[3]=<REF, 14> S = 3
p(f(X=W),h(f(X=W),W),f(W))
p(f(X=W),h(f(W),f(a)),f(W))
　　　　　　　　　　　　　　　　# ①h(_,f(a))のf(a)部分をユニファイする前に、まず、h(_,W)のWを先にX6とユニファイし。。。
unify_variable x6       |  X6 = HEAP[S=3] =<REF,14> S = 4  #注 ・・・ここで、もともとX5にセットされていた変数Wが、
                                                           #（X5が潰されてしまったにも関わらず・・・）ユニファイされている。
                                                           # それを救っているのはS=3である（h/2 のsubtermの２つめの項がS=3である）
                                                           # このしくみで、X5が上書きされても、その時記憶されていたアドレス(X5 = <REF,3>)
                                                           # を辿れるようになっているというべきか
                                                           # 理屈でいうと、X1に直接紐づくトップレベルの項に対応するレジスタ（今回の例では X2,X3,X4)
                                                           # さえ上書きされなければ、
                                                           # ユニファイの結果により、HEAP上のアドレスを辿ることができるので、それ以降のX5〜のレジスタは上書き
                                                           # されても、困らないということであろうと考える。
                           # ②その上で、X6とユニファイして 得た W と、f(a)とをユニファイしてゆく順番になっている。。。（構造化されている部分は、「フラット化」により
                           # 一旦一時変数を中継した形で、構造を表現するように表現しなおされている。）
                           （フラット形式にしたことにより、このような手順が「可能」になっていると言うべきか）（より構造的になっている方が後からユニファイする順番になっているのね）
get_structure f/1,x6    |  <REF,14> = deref(X6), STORE[14]==<REF,_>, HEAP[H=15] =<STR,16>, HEAP[15+1=16] =f/1, bind(14,15) H=17, mode = WRITE
unify_variable x7       |  HEAP[H=17] = <REF,17>, X7 = HEAP[17] =<REF,17>, H = 18 #注 変数を中継するので冗長に見えたが、ここまで見てゆくと
                                                                                  # あらゆるケースでユニファイを成立させるために必要な手順と思えてくる
get_structure a/0,x7    |  <REF,17> = deref(X7), STORE[17]==<REF,_>, HEAP[H=18] =<REF,19>, HEAP[19] = a/0,bind(17,18), H=20, mode = WRITE

p(f(W=f(a)),h(f(W=f(a)),W=f(a)),f(W=f(a)))
p(f(W=f(a)),h(f(W=f(a)),f(a)),f(W=f(a)))


この仕組みの巧妙さについての気づき
   ①あらかじめ、同一述語内の同一の変数は、同一アドレスにセット済みであること(コンパイル時にパターンマッチが終わっている)
   ②上記各instractionでは、その項の値が、構造体か？変数か？あらかじめ特定した上で、instractionが構成されていること
   （このため、各instraction処理実行のタイミングでは、型判定処理などは行わなくてよい）
   ③フラット形式にした後にユニファイすることで、構造データのあらゆるバリエーションに、機械的なプロセスで対処できる
新たな疑問
   ・HEAPが上書きされてしまったら、どのように、queryの解を返却するのだろうか？
   （どうやら、クエリ中の変数が格納されるレジスタの位置は、ユニファイ後も維持される様なので、コンパイルの途中で、
   　どの変数がどのレジスタ番号にセットされたか？その変数名は何か(Z? W?)を別途記録することさえできれば、答えを返すのは難しくなさそうだし、
   　そこの部分の実装だけであれば、難しいことは何も無いように思われる。ので、実際にクエリの答えを返却する方式は別途独自に実装すればよいと、
    仮に納得しておこう・・・(この実装は、実際は dereference そのもなので、ただプロンプト時に query中の変数をリストアップして call すればよいだろう)）

追加・変更された HEAP 領域データ
   0|STR|1|
   1| h/2 |
   2|STR|13|binded
   3|REF|14|binded
   4|STR|5|
   5| f/1 |
   6|REF|3|
   7|STR|8|
   8| p/3 |
   9|REF|2|
  10|STR|1|
  11|STR|5|
  12|STR|13|
  13| f/1  |
  14|STR|16|binded
  15|STR|16|
  16| f/1  |
  17|REF|18|binded
  18|REF|19|
  19| a/0  |


実行後のレジスタの状況
X3 = <STR,1>
X2 = <REF,2>
X5 = <REF,12>
X4 = <STR,5>
X1 = <STR,8>
X6 = <REF,3>
X7 = <REF,14>

Zは <REF,2> なので、デリファレンスすると、Z=f(f(a))
Wは <REF,3> なので、デリファレンスすると、W=f(a)
クエリに解答するには、Z=<REF,2> W=<REF,3>を何らかのかたちで覚えておく必要があるとおもう。
```
--

### 【デリファレンス(Dereferencing)】
変数のバインドが繰り返されると、参照関係のチェインが形成される。

デリファレンスは 関数 deref により実行される。  
この関数は、与えられた格納アドレスを元に 参照可能なチェインを辿り、
辿った先が、最終的に 未参照のREFセル か、あるいは 具体的な値(non-REFセル)に行き当たると、このアドレスを返却する。

### 【READ/WRITE mode】
ユニファイ命令は、状況に応じ2つのモードで動作する。
```
  (訳註: 項(term)を、HEAP内でマッチさせるか、もしくはHEAP上にビルドするかの、いずれかの目的によってモードを切り替える)
  (訳注: ユニファイしたときに、相手(pからみてq:※)が変数だったら、WRITE(で、こっちも変数をHEAP上に作るか構造データをHEAP上に格納する).
  　相手(pからみてq)が符合する構造体であったら、READ(で、さらにユニファイをつづける).)
```

- ビルド(WRITE mode)では、２つの set クエリ命令(後述)を実行する。
- マッチ(READ mode)では、
    HEAPからのデータを対応する位置にある項のデータとして認識できるか読み込み、
    これが成功した場合は、先に進む(proceeding)。さもなければ、失敗とする。
```
    (脚注 pからみてq:※ なぜそう言い切れるかというと、各命令は、p側から呼び出しているのであり、p側はあらかじめコンパイルされており、
    自分自身が変数か構造体かあらかじめ分かっており、そもそも、分かっているからこそ、get_structureなどの呼び出しができるからである。
    pからみて不明なのは、qがどういう構造なのか？であり、
    それは、qが投入されてはじめて判明することであり、あらかじめ想定することができない。)
```

### 【サブターム・レジスタ S 】(新設)
S は、READモードでマッチされた、HEAP上の次のサブタームのアドレスを保持する。`（訳註:この仕組みを使って、レジスタ変数参照から離れてゆく）`  
`  (訳註: WRITEモードでは使用されない)`  
```
(訳註: Sとは、get_structure 命令に続く、unify_XXXXのために、サブタームを、順番に参照できるようにするためのものと考えてよさそうだ。
  　ちなみに、サブタームは、以下の例のように順次隣接して呼び出されることが保証されているので、Sは単なるインクリメントで対処できるようだ。
    前述の命令を抜き出すと、
    get_structure p/3,x1
    unify_variable x2       |  x2 = HEAP[9]  =<REF,2>, S = 10
    unify_variable x3       |  x3 = HEAP[10] =<STR,1>, S = 11
    unify_variable x4       |  x4 = HEAP[11] =<STR,5>, S = 12
    ここでは p(x2,x3,x4)の、それぞれのサブタームとなる、x2,x3,x4を順に参照するために、Sを使用している。
    ・・・それなら、unify_variable 命令に、Sに当たるアドレスを付属させればいいじゃないか？とも考えるが、
    そうかもしれない、、、が、readモードとwriteモードで動きが異なるので、writeモードでは使用することのない、
    Sのアドレスを付属させない方針にしたということだろう。

    もう一つの理由として、(プログラム側の)コンパイル段階では、set_structure の段階で、
    readモードとなるのか wirte モードとなるのかは決定できないということがある。
    決定するのは、クエリを投入する段階なので、そこをコンパイル段階で表現するためには、別の制御の仕組み
    （例えば条件分岐を書けるようにして両方のパターンを書くようにするなど）が必要になってくるということもあろう。
    その上で、WAMでは read/writeモードの方式でやる決断をしているのだと考えよう。
  )
```

get_structure f/n,Xi インストラクションでは、(q との対比結果に応じて) Mode をセットする:  
もしも デリファレンス deref(Xi) の結果が・・・  
- REFセル(つまり未束縛変数)である場合は、`(訳註: これは、p側は構造体f/nなのに対し、q側は変数であったという場合にあたる)`
新しい STR セル(f/nをポイントしている)をバインド(後述)し、HEAPにPUSHする。  
そしてModeを WRITEにセットする。

- そうでない場合は、
    - もしもSTRセルが、ファンクタ f/n をポインティングしている場合は、レジスタ S には、後続の、このファンクタセルのHEAPアドレスを格納し、そしてModeを READ にセットする。
    - もしもSTRセルでないか、そうであったとしても、ファンクタが f/n ではなかった場合は、プログラムは失敗とする。

  ＜get_structure の擬似コード＞
 ```
  get_structure f/n,Xi ≡　addr ← deref(xi);
                            case STORE[addr] of
                              <REF,_> : HEAP[H] ← <STR,H+1>;
                                        HEAP[H+1] ← f/n;
                                        bind(addr,H);
                                        H ← H+2;
                                        mode ← WRITE;
                              <STR,a> : if HEAP[a] = f/n
                                        then
                                          begin
                                            s ← a + 1;
                                            mode ← READ;
                                          end
                                        else fail ← true;
                              other    : fail ← true;
                            endcase;
```

#### unify_variable Xi:
- READ モードでは、Xiレジスタに対して Sに格納されているアドレスからHEAPを参照した内容をセットする。
- WRITE モードでは、新たな未束縛REFセルをHEAPにPUSHし、これをXiレジスタにコピーする。

#### unify_value Xi:
- READ モードでは、Xiレジスタの値は、Sのアドレスの HEAPの項(term)とユニファイされる。
- WRITE モードでは、新セルをHEAPにPUSHし、Xiレジスタの値をセットする。

繰り返しになるが、各モードとも、Sは(1つ)増分される。

＜unify 命令の疑似コード＞
```
unify_variable Xi ≡ case mode of
                      READ  : Xi ← HEAP[S];
                      WRITE : HEAP[H] ← <REF,H>;
                              Xi ← HEAP[H];
                              H ← H + 1;
                    endcase;
                    S ← S + 1;

 unify_value Xi   ≡ case mode of
                      READ  : unify(Xi,S);
                      WRITE : HEAP ← Xi;
                              H ← H + 1;
                    endcase;
                    S ← S + 1;
```

### 【変数のバインド(Variable Binding)】
バインドは２つの格納アドレス間で実行される（この場合、少なくとも片方は 未参照セルであると想定している）。

今のところ(注)以下の実装とする:  
- 未束縛セルともう一方をバインド(bind)する。
  　（具体的には、未参照のREFセルのデータフィールドに他方のセルのアドレスを上書きする）
- もしも双方の引数が両方とも未参照のREFセルであった場合は、
    任意の片方に対して、もう一方をバインド(bind)する。

#### NOTE(注):
bindは、循環参照となる可能性があるため、これを防止するために occures-check テスト等（の実装）が必要となろう。

＜unify関数の疑似コード＞  
```
procedure unify(a1, a2: address);
  push(a1,PDL); push(a2,PDL);
  fail ← false;
  while not(empty or fail) do
  begin
    d1 ← deref(pop(PDL)); d2 ← deref(pop(PDL));
    if d1 ≠ d2 then
    begin
      <t1, v1> ← STORE[d1]; <t2, v2> ← STORE[d2];
      if(t1 = REF) or (t2 = REF)
        then bind(d1, d2)
        else
        begin
          f1/n1 ← STORE[v1]; f2/n2 ← STORE[v2];
          if (f1 = f2) and (n1 = n2)
          then
            for i ← 1 to n1 do
            begin
              push(v1 + i, PDL); push(v2 + i, PDL);
            end
          else fail ← true
        end
     end
  end
end unify;
```

```
(訳註  unify関数の動作の概略を記述すると
  ・ユニファイ対象の両者のアドレスを、プッシュダウンリストにプッシュ
  ・whileループに入る
    - まず、プッシュダウンリストをプルして、両者のアドレスを読み出す
    - 両者を比較して、片方が変数(REF)ならば、バインド処理をして終了
    - 両者とも同じファンクタ(f1/n1 = f2/n2)であるstructure だった場合は、
      ・structure の中の各項（通常は複数ある）を、プッシュダウンリストにプッシュ
    ループに戻る
  ・プッシュダウンリストが空になったら処理終了
  （気づき:構造体の比較を行う時に、中身を見る前に、ファンクタf/nのレベルで比較して判断している
  　　　　　ところが効率が良いと思った)
)
```

```
我々は、STORE[a]という表記を、address a に格納された、データセルの値の意味で用いる。  
(Heapでも、Xレジスタでも、あるいはその他ここで述べられていないグローバル構造体も含めて、
項を格納できるデータセルであれば何でも指すものとする）、一方で、HEAP[a]のように、
特に実装上の特徴を強調したい場合には、より具体的な表記を用いるものとする。(wam_bookより）
```

```
(考察:たしかに、addressさえ指定できれば、メモリ上のどの領域に存在するかは、参照だけを
目的とするならば、あまり問題にならないかもしれないな。。。）
```

---- (L0言語おわり) ----

## 【L1言語定義: Language L1】
  L1では、(これまで一括りにしてきた「項」を)以下の２つに区別していく:  
  - アトム(述語として定義された項)
  - 項(述語の引数として現れるもの)

### 【L0を拡張する(Extend L0 into L1)】
  - 構文(Syntax):  
    (L1は)L0とほとんど同じだが、L1では、プログラムは一階述語論理のアトムの集合とし、
    各アトムは最大で１つのファクト述語まで定義できるものとする。  
    `(訳註:つまり現段階では、連言の表現もできないし、バックトラックもできない)`
  - 構文の意味（Semantics）:  
    クエリの実行により、
    与えられたユニフィケーション式を解くために、最も適当な(ファクト)定義と対応づける(ユニファイする)。  
    それができない場合は、この述語のために呼び出すべきものが存在しないので失敗とする。

  L1の命令セットは、L0の命令セットを包含する。

  M1の場合、コンパイルされたコードは コードエリア(CODE)に格納される。  
  コードは一まとまりの命令の列であり、(呼び出すために)ラベルづけされる。  
  各命令はopコードおよびそれに続くオペランドの列から構成される。

  アドレス a (すなわち CODE[a])に格納された命令サイズは、instruction_size(a)により示される。

  各ラベルは、コードエリアへの シンボリックなエントリポイントであり、
  制御を適切なコードにラベルづけするために、命令中のオペランドとして使用される。  
  それゆえ（コンパイルした命令列を指定するためのキーとしての）手続き名をヒープ中に格納する必要はない。  
  `(訳註 クエリ中の引数データをヒープに格納したら、そのままcall(ラベル名を指定)するので、ヒープには何も格納しない)`


###  【Control instructions（制御命令）】
    標準的には各命令はシーケンシャルな順番で実行される。

####  【P (プログラムレジスタ)】(新設)
    レジスタP は、「次の」実行すべき命令のアドレスを保持する。`(訳註:つまり、コードエリア側のポインタ情報を保持するために新設した)`

  失敗が発生しないかぎり、通常のマシン命令では、暗黙のうちに
  Pが、instruction_size(P)の値でインクリメントされる。

  いくつかの命令では、シーケンシャルな実行をブレークするか、もしくは
  シーケンスの最後の時点で、いくつかの他の命令に接続することがある。  
  これらの命令は「制御命令」と呼ばれ、Pを通常とは異なる方法でセットする。

  M1（で定義される）各制御命令は・・・:
- call p/n ≡ P ← @(p/n);
  - @(p/n)は、p/nに対してラベルづけされた命令に対するコードエリアのアドレスである。
  - 手続き p/n が、定義されていない場合、処理は失敗し、abortする。
- proceed
  - 命令シーケンスの終了を意味する。

### 【引数レジスタ（Argument registers）】
L1では、ファクトtermとクエリtermとのユニフィケーションは、
単一ではなく、複数の方程式を一度に解くことになる。

M0では、X1レジスタには必ず、ルートとなる（単一の)項がセットされるが、
M1では、(上記の意味でのX1レジスタは省略され、代わりに)
　n個のアリティを持つ述語の n個の引数が、レジスタX1,...,Xnにシステマティックに割り当てられる(これを引数レジスタと呼ぶ)。

```
（訳註1:・・・つまり、M0でやっていた、X1レジスタへの格納は廃止し、その代わりに引数部分を直接割り当てるように
　変更しよう、と言っている（このことをx1レジスタ:単一 に対し、x1-xnレジスタ:複数 の方程式を解く、、、と言っているのかもしれない）。
　かつてのX１〜Xn+1に割当たっていた項そのもの+引数の割り当ては、M1では、
　X1-Xnに引数のみ、割り当てるようになる。そして、それをA1-Anというように呼び方を変えようというのである。
　そもそもM0においてX1に項そのものを割り当てて、これを参照させるのは、X1参照->各引数を参照する動作は(よく考えれば)冗長であり、
　直接各引数を参照させても何も不都合は起きないのだから、省略できるではないか？ということである。
　(そのあと call f/n でコードを呼び出すと、コード側で、引数を読む 命令が実行されるが、
　そのとき、引数の数は、コード側で知っているという前提に立てる。実際には、 call f/n としたときの、「n」
　はクエリ時に決定されるのであり、そのとき実際に 引数n個の f が存在するかは、call してみないと分からないということだが、call できれば、
　引数 n との噛み合わせはピッタリ符号するようになるので、間接的に、call f/n で引数がnであることを伝えていると言えなくもない)
　ということであろう。）
```
```
（訳註2：・・・もう１点、
　p/3の引数について、構造体が含まれる場合は、M0では、参照変数を作って(フラット化して）、最後に呼び出すように
　していたが、p/3のレベルの引数については、そうする代わりに、A1〜Anに直接割り当てるように変更している。
　①変数の場合は、これまでどおりレジスタに割り当てる（ただしAxに)
　②構造体の場合は、参照変数を作らずに、Axに割り当てる
　という動きになっているが、具体化は結構悩ましい。
　・・・それから、P/3のレベルでは、ボトムアップの規則が崩れているようにみえる(これは、P/3をHeapに格納することを省略しているので、
　理屈的には問題ではないだろうが、さらに、その下位構造では、やはりボトムアップに作り上げる必要があるだろう:それらは結局Heapに格納するので
　ボトムアップに構築するしかない、というのが結論である。。。このあたりの切り替えが、どうすればよいか、どうすれば機械的に処理できるか？が悩ましい。
　順序を気にしなくてよいならば、p/3まわりに処理だけを、処理変更するようなコードで乗り切れるような気がしなくもないが・・・)）
```
```
（訳註3:・・・ボトムアップにやっていると、最後にp/3にまで到達した段階で、Axであることが後からわかるような感じになり、コードの書き換えを
　するような感じになるような気がしてくるが、どうするか。。。まあ、コードの書き換えでもいいような気がしてきているが、
  p/3のコードは疑似的に作っておいて、p/3に付属するX1,X2,X3を、あとからA1,A2,A3にして、
  なおかつp/3のstructureコードは削除し、p/3の引数コードは、変数に関するものだけを残し
  あとは削除する、、、というふうにすると、命令の順序は忠実でないが、一応動くものができるような気がする）
```

今後、引数レジスタを指す場合、XiではなくAiと表記し、
（引数レジスタの）i番目が、（述語の）i番目の引数を保持していることとする。

またXiという表記は、引数レジスタとしては使用しない（NOTE:これは、単に名前づけの問題であり AiとXiは事実上同じものである。）

```
（訳註：この引数レジスタという考え方が、WAMの高い性能を支えるアイデアのひとつであり、
 クエリの引数が、必ずレジスタ群の先頭部分に固定的に配置されることにより、
 サブゴールへの引数渡しが省略できる(レジスタを直接参照させるこということか）メリットがあるとのこと
 （外部サイトによる情報）
 ）
 ```


たとえば、 アトム p(Z,h(Z,W),f(W))について、M1では、レジスタを以下のようにアロケートする。
```
        A1 = Z
        A2 = h(A1,X4)
        A3 = f(X4)
        X4 = W.
```
```
(考察: Wは、「X4」となっていることに注意。これは、クエリp(A1,A2,A3)としてみたときの、構造上のルートに位置する部分(それをArgumentといっている)
　　　　についてのみA1,A2,A3と割り振るのであり、構造上の下位部分(この例ではW)は、これまでどおり、Xiで表現するということである。
　　　　。。。そこまで、AとXを区別したくなる理由は今のところ承知していない
        -> 前述のとおりA1-A3は引数をそのまま引き継げて、かつレジスタ参照できるため、高速化に寄与しているため区別したい
        ということがだんだん分かってきた)
```
```
(考察:
以前のコードを併記すると、こうである(これだけみると、X1=... の行が削除されているだけ(それで、番号が１つ繰り上がっただけ)にみえる)。
＞＞＞＞＞＞＞
  X1=p(X2,X3,X4)
  X2=Z
  X3=h(X2,X5)
  X4=f(X5)
  X5=W.
＞＞＞＞＞＞＞
）
```

### 【引数命令(Argument instructions)】
  M1では、引数変数に対する制御命令が追加された

  L0と同様に、制御命令は、「最初に出現した変数」かその後に「再び出現した変数」かによって場合分けされる（query でも fact でも）。

#### queryでは・・・:  
  - i番目の引数位置において、変数が最初に出現したとき、
      新しい未参照 REF セルをHEAP領域にPUSHし、これを引数レジスタ(Ai)にもコピーする
  - その後に同じ変数が出現した場合は、引数レジスタ(Ai)からこれを(HEAPに)コピーする

#### factでは・・・:
 `(fact はここで唐突に出現しているが、プログラムの意であろう）`
  - i番目の引数位置において、変数が最初に出現したとき、
      値は、引数レジスタAiにセットする
  - その後に同じ変数が出現した場合は、Aiをユニファイする

    ＜引数命令の疑似コード＞
    ```
    put_variable Xn,Ai ≡ HEAP[H] ← <REF,H>;
                         Xn ← HEAP[H];
                         Ai ← HEAP[H];
                         H ← H + 1;

    put_value Xn,Ai    ≡ Ai ← Xn

    get_variable Xn,Ai ≡ Xn ← Ai

    get_value Xn,Ai    ≡ unify(Xn,Ai)
```

```
---
put_variable X4,A1    % ?-p(Z,
put_structure h/2,A2  %       h
set_value X4,         %        (Z,
set_variable X5       %           W),
put_structure f/1,A3  %              f
set_value X5          %               (W)
call p/3              %                  ). (<- ここで call ということは、CODEエリアに先にコードを格納しておく必要がある)
---
Argument registers for L1 query
?- P(Z,h(Z,W),f(W)).
```

```
(考察:
・変数Zに対応する、X4とA1は同じ値が入っており、明らかに冗長のように見える（なお変数Wに対応する、X5は冗長にはなっていない）。
・一方で、put_variable の仕様としては、２つの引数(Xn, Ai)が必要になっているので、仕方がないのかもしれない。
・set_variable A1 が許容されるのであれば、上記の冗長性は解消できると思うが、どうなのだろう・・・
)
```
```
---
p/3: get_structure f/1,A1 % p(f
     unify_variable X4    %    (X),
     get_structure h/2,A2 %        h
     unify_variable X5    %         (Y,
     unify_variable X6    %            X6),
     get_value X5,A3      %                Y),
     get_structure f/1,X6 % X6 = f
     unify_variable X7    %       (X7),
     get_strucutre a/0,X7 % X7 = a
     proceed              % .
---
Argument registers for L1 fact
p(f(X),h(Y,f(a)),Y).
```

```
（所感: 同じ query と fact のはずなのに、L0とはだいぶ命令が変わっていて、特に、命令がコンパクトになっている。。。一瞬見逃していた。。。）
（クエリ側を見ると、A1,A2,A3は新設している（そのため、例えば、Zは、X4とA1に両方同じものが入っているといった具合になっている）ただ、使用しているレジスタの本数は5本で変わっていない。
割り当て方を最適化した結果のように見えるので、本数が同じなのは、たまたまかもしれない）
(:クエリにて使用するレジスタ数は、①引数の数 + ②サブタームの数 + ③変数の数(ユニークにカウント)  で算出できそうである)
(:なお、「プログラム」によっては、追加でレジスタを使用する可能性もあるだろう。)
```
```
参考:＞＞＞＞＞
  (L0言語クエリ 「?-p(Z,h(Z,W),f(W))」のM0仮想マシンコード)
  put_structure h/2,x3
  set_variable X2
  set_variable X5
  put_structure f/1,x4
  set_value X5
  put_structure p/3,x1
  set_value X2
  set_value X3
  set_value X4

L0プログラム「p(f(X),h(Y,f(a)),Y).」の仮想マシンM0のマシンコード
  get_structure p/3,x1
  unify_variable x2
  unify_variable x3
  unify_variable x4
  get_structure f/1,x2
  unify_variable x5
  get_structure h/2,x3
  unify_value x4
  unify_variable x6
  get_structure f/1,x6
  unify_variable x7
  get_structure a/0,x7

こうやってみると・・・
・put_structure p3 / get_structure p3 の部分が省略されているため、コードが大幅にコンパクトになっている
・p3に対する、HEAPとレジスタのデータのやりとりが無くなるので、大幅に高速化される。
・また、query と code の引数(A1〜A3)渡しが、暗黙のうちに行われているとも言えるので、
　その観点としても際立った高速化がなされているといえる。
　（通常のプログラミング言語ならば、スタックに引数を保存して渡すことになるが、直接レジスタを引き継がせているので、
　　恐ろしく高速になっていると言えるだろう）
＞＞＞＞＞
```
---- (L1言語おわり) ----




## 【２】Languege L2: Flat Resolution

  L2は、Prologの基本言語仕様のうちバックトラックだけが未実装のものである。
  - L2は、L1をさらに拡張し、手続き処理として bodyを持っている場合も含める。
  - body部分は、atomの連言として定義する。
  - 各述語名につき最大１つの節(clause)を定義する。
    `(訳注: L2では、複数の clause は定義できない。まだバックトラックが実装されていないからである。)`

  #### ・構文(Syntax of L2):
      L2プログラムでは、手続きは、 'a0 :- a1,....,an.'形式で定義される  
      ここで、　n >= 0 かつ、 aはアトムとする。

      これまでファクトと呼んできたものは、 n = 0 の場合の節(clause)であるとし、
      ファクトの場合は ':-' シンボルを省略しているものであるとする。

      n > 0 の場合、節(clause)をルールと呼ぶ。

      ただ１つの body からなる goalを チェイン・ルールと呼び、そうでない場合を ディープ・ルールと呼ぶ。

      L2 クエリは、'?- g1,...gk.'形式のgoal列を許容する。  
      (ここで k >= 0 である。)

      Prolog言語では、変数のスコープは、表記された clause やクエリ内に制約される。

  #### ・構文の意味(Semantics of L2):
      クエリ '?-g1,...,gk.'をプログラムのコンテキストとして実行する。  
      これは、  
      クエリ要素(g1〜gkや導出されたbody)が全てなくなって成功するか、あるいはどこかで失敗するまで、
      繰り返し最左導出を適用する、手続き定義の集合であるとする。

### 最左導出(Leftmost resolution):
   - g1をhead定義とユニファイする（存在しなければ failする）
   - ユニファイに成功した場合、g1を、その body 部に置き換える
        スコープ内の変数は、ユニフィケーションによる束縛を受ける。

それゆえ, L2におけるクエリ実行は:
   - successにより終了するか
   - failにより終了するか
   - 永遠に終了しないか  
      のいずれかである  
    L2クエリの実行が success したことにより終了したときの'結果'とは、
    終了時に得た もとの変数と(デリファレンスしたあとの)値とのバインド結果のことである。


### 【Compiling L2】
    L2 節のヘッド部をコンパイルする手段は、M1のファクト命令で充足している。

基本的には各 goal をL1クエリとしてコンパイルしたものを連結することで、コンパイルされる。  
"しかしながら"、M2は、以下の2つの点に注意する必要がある。
   - goalシーケンスの実行継続に関する点
   - 引数レジスタの使用に関するコンフリクトの回避に関する点


### 【L2におけるファクト】
    さてL2では、(最初の)ファクト が成功した後も、
    その後続のgoal命令シーケンスに戻り、実行を継続しなければならない。

### 【継続ポイントレジスタ CP】(新設)
CPは、M2により 次の命令のアドレスを保存＆リストアするため使われる。  
(callから成功して処理が戻ったときに、それを継続する必要がある)

このため、L2のファクトは、M1の制御命令を以下のように変更する
```
    call p/n ≡ CP ← P + instruction_size(P);
                P ← @(p/n);

    proceed ≡ P ← CP;
```
以前と同じように、手続き p/n が定義されていない場合は、実行は失敗する。  
このシンプルな調整により、L2ファクトは厳密にL1ファクトとして翻訳される。`(訳註:つまりなにも変更されていない)`


### 【ルールとクエリ(Rules and queries)】
まず最初に、ルール  
      `P0(...) :- p1(...),...,pn(...).`  
は、以下のパターンに翻訳される  
```
      get arguments of P0 (P0の引数変数(複数)をget)
      put arguments of p1 (P1に対応する引数変数(複数)をput)
      call p1
      :
      put arguments of Pn (・・・同上)
      call pn
```
    (クエリの場合は、head 部のない、ルールの特殊なケースと考えることができる)

   - 1以上のbodyに現れる変数は、permanent と呼ばれ、
      その変数が最初に現れた手続き呼び出しよりも延命させなければならない。
   - それ以外のスコープ内変数は、temporary と呼ばれる。

### 【課題(Problem)】
同じ変数レジスタが、各body と goalで使用されるため、permanent 変数は、上書きされるリスクがある。

        例: p(X,Y) :- q(X,Z),r(Z,Y).

  生成された変数Y,Zが、qの実行の後にまだレジスタ内に
  そのまま存在しているかどうかは保証がない。

##### NOTE:
ルール中の変数が permanent か temporary かを決定するため、
head アトム は、最初の body ゴールの一部と認識される*。  
        `（例: 上記例の変数Xは、temporary である）`
```        
        (脚注 * : つまり head アトムと、最初の body ゴールにしか出現しない変数は、temporaryである。
        　　　　　思うに、head アトムに出現する変数は、実行結果の時に参照されるだけの存在であり、bodyにその変数が
        　　　　　使用されていても、複数出現しているとカウントするべきではないだろう。
        　　　　　(それに、headの変数は、head内部で複数使用するか、プログラムミスでもない限り必ずbody部にも出現することは分かり
        　　　　　 きったことである)
        　　　　　プログラム開始時点では、最初の body ゴールが読み込まれるわけだから、レジスタの内容が変更されないことは
        　　　　　保証されている。一方で、head アトムに存在する変数でも、２つめ以降の body に存在する変数の場合は、
        　　　　　レジスタの値は、通常書き換えなければならないので、permanent としなくてはならないだろう。
        　　　　　結局 temporary となれる変数の種類は以下に限定されるだろう。
                ① headにのみ出現する変数(headで複数使用されるようなケースを想定)
                ② headに出現し、かつ、body部のうち、最初の body に「のみ」出現する変数
                ③ body部中、単一のbody内でのみ出現する変数(そのbody内で複数使用されるようなケース))
```

###   【解決策(Solution)】
ある手続きに現れた permanent 変数(複数)を、その手続きの呼び出しと関連づけた environment(環境フレーム) に保存する。

M2は、手続きの permanent 変数(複数)とレジスタCPを、ランタイム・スタックに保存する。  
手続きをアクティベートするフレームを environment(環境フレーム) と呼ぶ。

### 【Environment Register E】(新設)
E は、直近の スタック上の environment(環境フレーム) のアドレスを保持する

M2のスタックは、以下のようなフレームの リンクドリストとして構成される。
```
      E     [CE (一個前の environment(環境フレーム))]
      E + 1 [CP (継続ポイント)]
      E + 2 [n (permanent 変数の数)]
      E + 3 [Y1 (permanent 変数1)]
        :
      E + n + 2 [Yn (permanent 変数n)]
```
(我々は permanent 変数を Yiと書き、Xi を temporary 変数として表記することにする)

 environment(環境フレーム) は、手続きエントリ call 上の、スタックにプッシュされ、
    そのリターン上にポップされる。
```
      例: p0(...) :- P1(...),...,pn(...).
    　は、以下のM2コードに翻訳される。
        allocate N
        get arguments of P0 (P0の引数変数(複数)をget)
        put arguments of p1 (P1に対応する引数変数(複数)をput)
        call p1
          :
        put arguments of pn (・・・同上)
        call pn
        deallocate
```
- allocate N
スタック上に、N個の permanent 変数のフレームとして environment(環境フレーム) を生成した上でスタックにプッシュする。
- deallocate
スタック先頭の environment(環境フレーム)を廃棄し、
廃棄された　environment(環境フレーム)からリカバリされた実行継続ポイントをセットする

つまり・・・  
<allocate deallocate の疑似コード>
```
        allocate N ≡ newE ← E + STACK[E+2] + 3; (訳註1)
                      STACK[newE] ← E; (訳註2)
                      STACK[newE +1] ← CP;
                      STACK[newE +2] ← N; (訳註3)
                      E ← newE;
                      P ← P + instruction_size(P);　
                      （考察: allocate 命令では、個々のpermanent変数そのもの保存はしておらず、領域だけ確保している。）


        deallocate ≡ P ← STACK[E+1] (訳註4)
                     E ← STACK[E]
```

```
(訳註1: 新たなEの位置 = 現在のEの位置 + 現在のEのpermanent変数の数N + 現在のEが管理上保持するスタックの個数3(E,CP,N)
 (というかその先の１個を指している)、と理解する )
```
```
(訳註2: 現在のEの位置を保持しているため、先に進んでも、ここを参照すると、1つ前に戻れると理解)
```
```
(訳註3: この時点では、paramente変数の数Nだけを格納し、そのN個分のスタックを確保しているわけでではないと理解)
```
```
(訳註4: P は、P-instruction_size(P)、ではなく CP がセットされることに留意)
```
```
＜プログラム例＞
---
p/2 : allocate 2           % p
      get_variable X3,A1   %  (X,
      get_variable Y1,A2   %     Y):-
      put_value X3,A1      %          q(X,
      put_variable Y2,A2   %              Z
      call q/2             %               ),
      put_value Y2,A1      %          r(Z,
      put_value Y1,A2      %              Y
      call r/2             %               )
      deallocate           %                .
---
M2 machine code for rule p(X,Y) :- q(X,Z),r(Z,Y).
```
```
(訳註:
 意外と明示的に書かれていないが、Y1,Y2は、レジスタではなく、environment(環境フレーム)上の保存領域と解釈すべきと考える。
 そこで、
 　　get_variable Yn,An や get_value Yn,An では、Anの値を、environment(環境フレーム)上のYnにコピーし、
 　　put_variable Yn,An や put_value Yn,An では、environment(環境フレーム)上のYnの値を、Anにコピーする
 というように解釈すべきと考える。
 とすると、上記４つの命令は、Ynにも対応できるように改修が必要ということになる。
 また、何がYn(parmanent変数)となるか？はコンパイル時に決定するので、判定ロジックが追加で必要となる。
 逆に言うと、それだけで、実現できる。
)
```
<疑似コード>
```
put_variable Yn,Ai ≡ addr ← E + n + 1;
                     STACK[addr] ← <REF,addr>;
                     Ai ← STACK[addr];
                     P ← P + instruction_size(P);
```



## 【３】純粋Prolog (Language L3: Pure Prolog)

  ### ・構文(Syntax of L3):
  - L3 はL2を拡張し、選言的な定義を許容する(注釈:つまり複数定義を可能とし、バックトラックを許す)
  - L2 と同じく、L3プログラムは、手続き定義の集合とする。
  - L3 における定義とは、順序づけられた、節の列(sequence)とする。
    （つまり、ファクトやルールの列(sequence)である）。
    　しかもこの節は、同一の述語名を共有する head アトムのすべてからなる。  
    　- 手続き名は、この定義により特定される。
  - L3 クエリは L2と同様である。


 ### ・構文の意味(Semantics of L3):
  - top-down最左導出により処理される。これはSLDレゾリューション解析の一種である。
  - ユニフィケーションの失敗は、実行全体の中断となることはなくなり、
    バックトラッキングにより他の選択を実行する。  
    つまり(ユニフィケーションが)失敗したその時、直前の(別の)候補が選択され、リトライされる。

  M3は M2の設計を変更し、他の選択枝を提示できるように各手続き呼び出しの状態を保存する。

  我々はこれを、選択ポイント（choice point)と呼ぶことにする:
    それは、失敗した計算のすべての影響を元に戻して、
    次の選択枝を試行するために必要な全ての関連情報を含んでいる。

  M3 では、選択ポイントをスタック内のフレームとして管理する(まさにenvironmentフレームのように)
  両者のスタックを区別するため、environment スタックを、ANDスタック
  選択ポイントスタックを、ORスタックと呼ぶ。

### 【バックトラックレジスタ: B】(新設)

B は 直近の選択ポイントのアドレスを保持する。

  - 失敗した場合、Bで示される選択ポイントフレームを元に、リカバリーされた状態から
    計算が再開される。
  - もしもフレームがこれ以上の選択枝を提示できなくなった場合、ORスタックをポップして
    １つ前のBが存在する場合は、Bによりリセットする。  
    さもなければ、計算全体が最終的に失敗する。

   ##### NOTE:
    仮に 1つの節だけが定義されている場合は、選択ポイントを作る必要はない。  
    この場合は、M2と全く同じ取り扱いとなる。


  １以上の選択肢が定義された場合は、
    ・選択ポイントフレームは、最初の選択肢により生成される
    ・その上で、それは（試行されるべき次の選択肢がある限り）中間の選択肢により
      更新される（ただし最後の選択肢は除く）
    ・最終的に、最後の選択肢により破棄される。

### 【環境の保護(Environment protection)】

  ##### 課題(Problem):
  (決定論的な)L2では、ルールの終了時点での environment(環境フレーム)
  の再配置は安全であった。  

  これは、L3ではもはやそれは正しくない:  
  直前の失敗は、environment が再アロケートされたことによるルールの適用中
  に計算状態からの選択により再評価される
```
  <プログラム例>
    Program:
      a:- b(X),c(X).
      b(X):-e(X).
      c(1).
      e(X):-f(X).
      e(X):-g(X).
      f(2).
      g(1).

    Query:
      ?- a.
```
   - a のenvironmentをアロケート
   - b を call
   - b のenvironmentをアロケート
   - e を call:
      - e の選択ポイントを作成してプッシュ
      - e の environment をアロケート
```
      ＜スタックの格納図＞
           |        :         |
           |Environment for a |
           |Environment for b |       |        :         |
      E -> |Environment for e |  B -> |Choice point for e|
```

   - f を call;
   - 成功 succeed (X=2);
   - e の environment を deallocate
   - b の environment を deallocate
```
      ＜図式＞
      |        :         |       |        :         |
 E -> |Environment for a |  B -> |Choice point for e|
```
aのbody部の実行を継続:  
   - c を call;
   - 失敗(X=2≠1);

    選択ポイントは、eの選択節としてBにより示される、
    しかし、bの environment は、失われる。(ここがProblemか)

    M3は、既存の選択ポイントよりも時間的に先行する environment フレームの回復不能な
  　deallocation を防止する必要がある。

    ##### IDEA:
    全ての選択ポイントは、
    それが生成されるようにも前に存在していた全ての environment(環境フレーム)
    の deallocation から"保護"しなければならない。

    ##### Slution:
      M3は、environment(環境フレーム)と選択ポイントを同一のスタックで使用するようにする:  
        これからは、選択ポイントは、全てのより古いenvironment(環境フレーム)をキャップ(保護)する。

   - 選択ポイントがアクティブである限り、
      （明示的にdeallocateされたものであっても）より古い environment(環境フレーム)の上書きを排除して、
      強制的に environment(環境フレーム) のアロケーションを維持する。
   - この選択ポイントから別の選択肢に戻ると、deallocateされたが 保護されている environment(環境フレーム)
      　の安全な復活(resurrection)が自動的に行われる。
   - この保護は必要とされる限り持続するが、
      　この選択ポイントがなくなりしだい(disappers)、明示的にdeallocateされた
        environment(環境フレーム)はすべて安全に上書きされることになる。

    先の例に戻る・・・(Back to our example):  
   - a の environment をアロケート
   - b を call
   - b の environment をアロケート
   - e を call
        - e の選択ポイントを作成してプッシュ
        - e の environment をアロケート
```
        ＜図式＞
         |               :            |
         |       Environment for a    |
         |       Environment for b    |
    B -> |       ChoicePoint for e    |
    E -> |       Environment for e    |
```


      ・f を call
      ・成功(X=2);
      ・e の environment をデアロケート
      ・b の environment をデアロケート
```
      ＜図式＞
       |               :             |
  E -> |       Environment for a     |
       |Deallocated environment for b|
  B -> |       Choice point for e    |
```

    aのボディ部の実行を継続(Counting with execution of a's body:)
      ・c を call
      ・失敗(X=2≠1);

    この時点で、M3は e の選択ポイント(Bで示されていた)を使って、
    安全に状態を回復することができる。
    この場合、復元する保存された environment は、
    この選択ポイントの作成時において現在のもの（つまりb）である。
      ・バックトラックする;
      ・e の選択ポイントを破棄;
    (環境の)保護はこの時点で(安全に)終了する。

proceed のための、最後の選択肢の実行(Execution of the last alternative for e procceds with):  
```
    ＜図式＞
B -> |                             |
     |               :             |
     |       Environment for a     |
     |       Environment for b     |
E -> |       Environment for e     |
```

### 【バインド処理のアンドゥ(Undoing bindings)】
バインド処理の影響は、選択肢の再検討の時点で無効化しなければならない。

M3は、バックトラック時に　unbound するためにリセットが必要な全ての変数をトレイル と呼ばれるデータエリアに記録する。

###  【トレイルレジスタ TR】(新設)
TR は、次の使用可能なTRAILのアドレスを保持する

##### NOTE:
条件付きバインドだけが、トレイルされる必要がある。

  条件付きバインドとは、影響を受けた変数のうち、現在の選択ポイント
  を生成するよりも前に存在していたものを指す。

### 【ヒープ・バックトラック・レジスタ HB】(新設)
HBは、最新の選択ポイントが生成された時点のHの値を保持する。

  - HEAP[a] は、a < HB の場合 conditional である。
  - STACK[a] は、a < B の場合 conditional である。


### 【選択ポイントにはどんなデータが含まれる？】
   - 引数レジスタ A1,...,An (n は、定義の代替選択を提供する手続きのアリテイである)
   - 現在の environment （レジスタEの値）。  
     保護された environment として取り扱う。
   - 継続ポインタ（レジスタCPの値）。  
     現在の選択(choice)はこの値で上書きされる。
   - 最新の選択ポイント（レジスタBの値）。  
     現在の選択ポイントによって提供されたすべての選択肢が失敗した場合にバックトラックする。
   - 次の節(レジスタBPの値)  
   （現在選択されているものが失敗した場合にこの定義を試す）  
    より多くの選択肢が存在する場合、このスロットはこの選択ポイントまで、バックトラックするたびに更新される。
   - 現在のTRAILポインタ（レジスタTRの値）。  
    これはバックトラック時にTRAILを巻き戻す場所の境界として必要。
   - 現在のHEAP領域の先頭（レジスタHの値）  
   　失敗した試行中に構築された すべての構造体および変数の HEAP領域を回復（ガベージ）するために必要。
```
    Choice point frame:
     <図表>
     B     | n (number of arguments)       |
     B+1   | A1 (argument register 1)      |
                       :
     B+n   | An (argument register n)      |
     B+n+1 | CE (contunuation environment) |
     B+n+2 | CP (continuation pointer)     |
     B+n+3 | B  (previous choice point)    |
     B+n+4 | BP (next clause)              |
     B+n+5 | TR (trail pointer)            |
     B+n+6 | H  (heap pointer)             |
```
##### NOTE:
M3では、M2の allocateの定義を変更する:
```
      <allocate(変更後) の疑似コード>
      allocate N ≡ if E > B
                      then
                        newE ← E + STACK[E+2] + 3
                      else
                        newE ← B + STACK[B] + 7;
                    STACK[newE  ] ← E;
                    STACK[newE+1] ← CP;
                    STACK[newE+2] ← N;
                    E ← newE;
                    P ← P + instruction_size(P);
```
### 【選択命令(Choice instructions)】
    与えられた 複数節の定義では、M3は、３つの命令を使用して取り扱う:
1. 最初の節
2. 中間の節(最後の節を除く)
3. 最後の節

  それぞれ・・・:  
1. trey_me_else L  
      新しい選択ポイントフレームをスタックにアロケートし、
      それを次の節のフィールドとして L に設定する。  
      そして、現在のコンテキストにおける他のフィールドは
      これをポイントするように、Bにセットする。
2. retry_me_else L  
      現在の選択ポイントから全ての情報をリセットし、
      次の節のフィールドである L で更新する。
3. trust_me  
      現在の選択ポイントから全ての情報をリセットし、
      その上で B をリセットすることにより、これを破棄(discard)する。

### 【バックトラック(Backtracking)】

M3では、すべてのM2命令が失敗する可能性がある  
    (つまり、いくつかのユニフィケーション命令と、全ての手続き命令が)
    が、このようなすべての選択肢が失敗した場合に、
    以下のようなオペレーションを実行する。
```
    <バックトラックの疑似コード>
      backtrack ≡ P ← STACK[B + STACK[B] + 4];
      (訳註:つまり、BPをセットする)
```
(backtrackでは)通常のシーケンスに従って進むのとは対照的に、Pを無条件にセットする  
(その上で)スタックにこれ以上の選択ポイントが存在しなくなった場合には、
最終的に失敗し、実行は異常終了する。  
```
    (考察:
      ここで論じている backtrack は、前述の truse_me が失敗したときに、より深くバックトラック
      するために、呼び出し元の、述語の次の選択肢にまで、ジャンプするために行う操作と考える。
      そう考えると、truse_me が失敗したときの動作に組み込まれている　のかな？と考えるが、
      詳細なコードも示されていないため、いま一つわからないところがある。

     　・・・wambookを読むと、そうではなく、tryme系の命令は、単純に選択ポイントの設定をしているだけ
      のようである。backtrackは、unifyなどに失敗した場合などに、呼び出されると考えるべきものだそうである。
      ・・・そうなると、get_structure や、put_valueなど、改修が必要ということになる。
      それで、backtrackがやっていることは、単にPをセットしなおして、次のジャンプ先に飛ばすことだけのようである。
      たとえば、
        try_me_else L では、Bをセットしなおして、選択ポイントを設定し、次のジャンプ先を L にしている。
        backtrack では、次のジャンプ先である L にジャンプする。
      という動きになっている。
    )
```
```
   <疑似コード>
   try_me_else L ≡ if E > B
                     then newB ← E + STACK[E + 2] + 3
                     else newB ← B + STACK[B] + 7;
                   STACK[newB] ←  num_of_args;
                   n ← STACK[newB]
                   for i ← 1 to n do STACK[newB + i] ← Ai;
                   STACK[newB + n + 1] ← E;
                   STACK[newB + n + 2] ← CP;
                   STACK[newB + n + 3] ← B;
                   STACK[newB + n + 4] ← L;
                   STACK[newB + n + 5] ← TR;
                   STACK[newB + n + 6] ← H;
                   B ← newB;
                   HB ← H;
                   P ← P + instruction_size(P);

   retry_me_else L ≡ n ← STACK[B];
                    for i ← 1 to n do Ai ← STACK[B + i];
                    E  ← STACK[B + n + 1];
                    CP ← STACK[B + n + 2];
                    STACK[B + n + 4] ← L;
                    unwind_trail(STACK[B + n + 5],TR);
                    TR ← STACK[B + n + 5];
                    H  ← STACK[B + n + 6];
                    HB ← H;
                    P  ← P + instruction_size(P);

   trust_me        ≡ n ← STACK[B];
                    for i ← 1 to n do Ai ← STACK[B + i];
                    E  ← STACK[B + n + 1];
                    CP ← STACK[B + n + 2];
                    unwind_trail(STACK[B + n + 5],TR);
                    TR ← STACK[B + n + 5];
                    H  ← STACK[B + n + 6];
                    B  ← STACK[B + n + 3];
                    HB ← H;
                    P  ← P + instruction_size(P);

   procedure unwind_trail(a1, a2 : address);
     for i ← a1 to a2 -1 do
       STORE[TRAIL[i]] ← <REF,TRAIL[i]>;
   end unwind_trail;

   procedure trail( a: address);
     if (a < HB) or ((H < a ) and (a < B))
       then
         begin
           TRAIL[TR] ← a;
           TR ← TR + 1;
         end
   end trail;

   --- bind関数 (trail対応後）
   procedure bind(a1, a2: address);
   <t1,_> ← STORE[a1]; <t1,_> ← STORE[a2];
   if (t1 = REF) and ((t2 ≠ REF) or (a2 < a1))
     then
       begin
          STORE[a1] ← STORE[a2]; trail(a1)
       end
     else
       begin
          STORE[a2] ← STORE[a1]; trail(a2)
       end
   end bind;
```

### 【L3コンパイルについてのまとめ(Recapitulation of L3 compilation)】
- M3コードでは、単一節の定義に対して生成されたものは、
    　M2のL2プログラムに対して生成されたものと同一である。

- 2つの節で定義された　手続き p/n の場合は、以下のようなパターンになる:
        p/n : try_me_else L （最初の節のためのコード）
        L   : trust_me       (2つめの節のためのコード)

- それ以上の数の節定義についは以下:
        P/n : try_me_else L1
        L1  : try_me_else L2
        Lk-1: trey_me_else Lk
        Lk  : trust_me

 各節は、M2の単一節L2と同じように翻訳される。

  Example,
      p(X,a).
      p(b,X).
      p(X,Y) :- p(X,a), p(b,Y).

```
  ＜サンプルコード＞
  ---
  p/2: try_me_sle L1        % p
       get_variable X3,A1   %  (X,
       get_structure a/0,A2 %     a)
       proceed              %       .
  L1 : rety_me_else L2      % p
       get_structure b/0,A1 %  (b,
       get_variable X3,A2   %     X)
       proceed              %       .
  L2 : trust_me             %
       allocate 1           % p
       get_variable X3,A1   %  (X,
       get_variable Y1,A2   %     Y):-
       put_value X3,A1      %          p(X,
       put_structure a/0,A2 %              a
       call p/2             %               ),
       put_structure b/0,A1 %          p(b,
       put_value Y1,A2      %              Y
       call p/2             %               )
       deallocete           %                .
---
M3 code for a multiple-clause procedure
```



---- (L3言語おわり) ----





## 【４】最適化 (Optimizing the Design)


##### WAM原理1
　　ヒープスペースは、できる限り控えめに使用されるべきであり、ヒープ上に構築されたものは、相対的に永続的なものであるべきである。

##### WAM原理2
　　レジスタは、不要なデータ移動を極力避けてアロケートされなければならないし、そしてコードサイズもまた極力最小化されるよう調整されるべきである。

##### WAM原理3
　　（頻繁に発現する）特定の条件においては（仮に一般的なケースの命令処理においては、十分適切に制御されていたとしても）
　　その特異性による恩恵で、スペースや時間を節約することができるのであれば、特別にその便宜を図るべきである。



### [Heap representation]
より望ましい、ヒープの表現は以下となろう: (p(Z,h(Z,W),f(W))
```
   0|h/2  |
   1|REF|1|
   2|REF|2|
   3|f/1  |
   4|REF|2|
   5|p/3  |
   6|REF|1|
   7|STR|0|
   8|STR|3|
```
　　ストアやレジスタからの参照は全て <STR,5> 形式のセルになっているが
　　実のところ、各ファンクターセルの前に、定型的な STR セルを割り当てる必要性はないのである。

```
-------------
本文冒頭の Heap レイアウトを参考までに再掲載する・・・
(p(Z,h(Z,W),f(W))
   0|STR|1|
   1| h/2 |
   2|REF|2|
   3|REF|3|
   4|STR|5|
   5| f/1 |
   6|REF|3|
   7|STR|8|
   8| p/3 |
   9|REF|2|
  10|STR|1|
  11|STR|5|
-------------
```
このために必要なことは、put_structure 命令を次のように変更することだけである:
```
put_structure f/n,Xi ≡ HEAP[H] ← f/n;
                       Xi ← <STR,H>;
                       H ← H + 1;
```
```
------
比較のために、元の定義を併記する。
put_structure f/n,Xi ≡ HEAP[H] ← <STR,H+1>;
                       HEAP[H+1] ← f/n
                       Xi ← HEAP[H];
                       H ← H + 2;
(Xiには、最適化後も同じように <STR,H> がセットされており、基本的なレジスタの使用方法には変更がないことが分かる)
------
```


### Constants,lists, and anonymous variables

##### Constants
    unify_vafiable Xi
    get_structure c/0,Xi

これは、１つの特殊化された命令に単純化できる。  
```
　　 unify_constant c  
```
そして  
```
    put_structure c/0,Xi  
    set_variable Xi  
```
もまた、単純化できる:  
```
    set_constant c  
```

類似的に、put と get 命令もまた、定数の特別な取扱によって単純化できる

我々は、定数を識別するため、この種のデータセルに新たに'CON'タグを付与する必要がある。
e.g., 構造体 f(b,g(a))を例にすると、アドレス10から始まる、ヒープ表現は以下となる:
```
    8|    g/1    |
    9| CON |  a  |
   10|    f/2    |
   11| CON |  b  |
   12| STR |  8  |
```
定数に対する、レジスタからのロードや、変数とのバインドするときの、Heap のスペースが軽減されることになる:
これは、文字通りの値として取り扱われる。
```
Constant-handling instructions:
・put_constant c,Xi
・get_constant c,Xi
・set_constant c
・unify_constant c
```
<コード定義は省略>

Lists



























































＜＜＜＜ TO BE CONTINE ＞＞＞＞

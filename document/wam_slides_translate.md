(This translation is created for studying basic idea of WAM)

# Warran's Abstract Machine
#### A Tutorial Reconstruction
#### Hassan Ait-Kaci

### はじめに
  WAMは1983に David H.D.Warren により考案されたものである。
  しかし、ごく最近に至るまで それがどのような仕組みで動作するのか、明確な解説がなされてこなかった。

本書では
- 最も単純な定義をもとに WAM仮想マシンの設計を行う。そしてこれを段階的に拡張しながら説明する。
- この説明の中で、設計上の特徴について 根拠を示しながら完全な解説を行う。


【目次】
1. [ユニフィケーション](#chapter1)
2. [フラット・レゾリューション](#chapter2)
3. [純粋Prolog](#chapter3)
4. [最適化](#chapter4)

　　　
## <a name="chapter1"> 1. ユニフィケーション(Unification—Pure and Simple) </a>


### 【一階述語論理の項】
prologで使用する 一階述語論理の項について、以下に定義する。
* 変数記号:　大文字で始まるアルファベット列で表す。
* 定数記号:　小文字で始まるアルファベット列で表す。
* 構造体(structure):

  f(t1,t2,t3・・・)の形式で表す。
なお f はファンクタ(関手)と呼ばれる 一種のシンボルである。

  ここで t1,t2,t3・・・ は一階述語論理の項とする `(例:f(X),f(a,g(X,h(Y),Y),g(X))・・・)。`

  f/n と表記した場合、 シンボルが f　アリティが n　のファンクタを意味する。（アリティとは 項の個数のこと）

  定数 c は 構造体の特別なケースとし、ファンクタc/0 と等価とする。

```
訳註:wikipediaより抜粋
一階述語論理の項 (term) は次のように帰納的に定義される
 1. 変数と定数記号はすべて項である。
 2. t1,・・・,tn が項で、f がアリティ n の関数記号ならば、f t1,・・・,tn は項である。
 3. 上記の 1. と 2. によって項とされるものだけが項である。
```

### 【L0言語定義:Language L0】
#### 構文(Syntax)
- ' t '　:プログラム構文
- ' ?-t ' :クエリ構文

ここで t とは、(それ自体は)変数ではない 一階述語論理の項とする。<br>
項の中で変数が現れることは許されるが、変数のスコープは プログラム(やクエリ)の項内に限定されるものとする。

#### 構文の意味(Semantics)
プログラム p と クエリ ?-q の MGU(most general unifier:最大汎用単一子)を導出する。<br>（訳註:これをユニファイという）
- p と q がユニファイできない場合は失敗となる。
- p とユニファイして得られた q の変数とバインドすることで成功となる。

L0では、処理が途中で失敗となった場合は それ以降の処理を中断する。



### 【仮想マシン M0 】
**項をHEAP上に格納する**
- HEAPはグローバル格納領域上にあるデータセルの配列であるが、仮想マシンM0はこの領域を利用して 項を格納する。

#### HEAP上の格納例　p(Z,h(Z,W),f(W))
```
 0|STR|1|
 1| h/2 |
 2|REF|2|
 3|REF|3|
 4|STR|5|
 5| f/1 |
 6|REF|3|
 7|STR|8|
 8| p/3 |
 9|REF|2|
10|STR|1|
11|STR|5|

(アドレス 7 を起点とする)
```

```
訳注：
項(term)の階層構造を、(計算機で取扱いが容易な)配列形式に変換している。
配列上で階層関係を表現するため、ポインタでメモリアドレスとの関連づけを行い、
ポインタを参照すると、データ型とデータ長（＝要素の数）が判別できるようになっている。
（各データは、配列で格納する関係上、固定バイト長のデータで取り扱う必要がある。

一方で、データ構造自体は、配列の格納領域が許す限り自由な構造を格納でき、事実上制約が無い。
ただし、格納する時点で、保存するデータ長が判明していなければならないという保存上での制約はあろう。）
（個人的疑問: 10 は、STR|0|にならないのか？ 11は STR|4| にならないのか？そうしないと、
　「アドレス7を起点とする」という表記と整合性が合わないのではないか？
・・・自己解決 4|STR|5| の表記と、 11|STR|5| の表記は、いずれも、5| f/1 | を指しており、両者は同格であるとすると、
全く整合する表記と言えそうだ(起点となるアドレスが、4および11、というように複数存在しえると言い換えるといいだろうか)。
4|STR|5| の存在意義がいまひとつピンとこない、単なるセパレータのようなものに見えてくる、
省略したら不都合があるのだろうかと感じる者もいるだろうが、実は後に最適化により取り除かれるので、やはり冗長な表現であると言える。
初期段階の説明のために導入されていると考えて良いようだ。）
```

### 【ヒープ領域上のデータセルについて】
- 変数セル:　<REF,k> で表す (kは格納アドレス(=HEAPのインデックス))
- 構造体セル:　<STR,k> で表す (kはファンクタセルの格納アドレス)
- ファンクタセル:　ファンクタ表記をそのまま格納する(タグは省略)

### 【その他の約束事(Convention)】
- アドレス k に格納された 未束縛(unbound)の変数は <REF,k>と表現する。<br> (つまり自分自身の格納アドレスを指す)
- 構造体 f(t1,・・・,tn)の場合、全部で n+2 個のHEAPセルを消費する。<br> (+2となるのは、STRセルとファンクタセルが 追加で消費されるため）
- f(t1,・・・,tn)の最初のセルは <STR,k> である。ここで k は ファンクタセル(f/n が格納されている)の格納アドレスである。
   (隣接セルでない場合もある:前例の 11番目のセル などがその例)
- ファンクタセルは、必ず 直後のn個の隣接セルが続いて格納される。
    例えば HEAP[k] = f/n であれば、HEAP[k+1]は t1に割当てられ、HEAP[k+n]はtnに割り当てられる。
<br><br>
### 【L0言語クエリのコンパイル】
解くべき方程式の一方(つまりquery側)の準備をする。
コンパイルにより(単なる文字列である)クエリ項「?- q」を翻訳して、一連の命令シーケンスに変換する。
この一連の命令シーケンスは、これを実行すると HEAP上に q のための形式的なデータ構造を構築(格納)するようにデザインされている。

### 【変数レジスタ】
変数レジスタ X1,X2,・・・, は、HEAPデータセル上に項(term)のデータ構造を格納する際に、一時的な記憶場所として使用される。
これら変数レジスタは各項に割り当てられ、また各サブタームに対しても それぞれ1つずつ割り当てられる。

### 【その他の約束事(Convention)】
- 変数レジスタは、利用可能なインデックスのうち 最小の番号のものから順に割当てる。
- (このため)レジスタ X1 は、(結果的に)必ず最も外側の項に割当てられる。
- 同じ変数の場合は同一のレジスタを割り当てる。
```
  たとえば、項 p(Z,h(Z,W),f(W)) に対して割り当てられる、レジスタの内容を例示すると以下となる。
  X1=p(X2,X3,X4)  :最も外側の項
  X2=Z            :変数Zに割り当てられる変数レジスタは、直近の使用可能なインデックス(index=2) 番号のレジスタから選ばれる
  X3=h(X2,X5)     :複数出現した変数(Z)は同一のレジスタ(X2)が割り当てられる
  X4=f(X5)        :変数(W)も同様である(X5)
  X5=W.
```
```
（疑問・・・ X5=Wが一番最後のインデックスになっているのがピンとこない。
だが、それぞれの項の内部の変数は後続のレジスタ番号が指定されているので、動的に組み立てる
のであれば、一度書き直しをしなければならないし、予め上記のような指定をコーディングされる
ものを読み込むのであれば、見た目上の順序はあまり問題ではなく、ただ整合していればよい
ということにはなる。）

(訳註:
上記変数割当ては、横型探索のような動きにみえる、上記の例だと・・・
最上位階層:p()
次の階層: Z,h(),f()
最下位層: Z:2回目,W,W:2回目
という風に序列されるとみればよいかもしれない
  - 変数Zが変数の中で最初、次にZ:2回目、次にW、次にW(2回目)の順で変数割当てを調整するとみる
・・・しかし、このような横型探索のような動きは、実装上は面倒な気がしてくる・・・
そもそもこの表記自体は、あくまでも論理的なものであると捉えられるのかもしれないし、別の方法で実装しても
よいような気がするし、、、まだよく分からないところがある。
)（一番ひっかかるのは、X3あたりでX5を指定しているが、この段階で、どうやってX5を予測できたのか？その時点では、
変数のインデックスの位置が一見決められないように思えてしまうこところである。
・・・ただ、X1を決めた時点で、サブタームが X2,3,4と生み出されるので、次に変数を設定すると、X5にならざるを得ない
というふうにみると、納得できるのかもしれない・・・）
```

### 【フラット形式（Flattened form）】
(訳註: prolog は項(term)内で複雑な構造(木構造)を表現できるが、これを可能とするためには、仮想マシンによって機械的に処理できるように、フラットな構造（つまり木構造をバラバラにして、リレーショナルな表現）に変換する必要がある。)

いかなる項も、以下の連言式の集合と等価である
```
Xi=X 又は Xi=f(Xi1,...,Xin),(n >= 0)
```
ただし Xiは すべて区別可能な「新規」の変数名とする。<br>（訳註:ここでいう「新規」とは、重複や使い回しがない という意味と理解)


- 外部(で指定された)変数名は保持する意味がない<br>
        (訳註:つまり、X2やX5で識別できるので、ZやWの名前そのものを保持することには意味がなく、X2=Z や、X5=W などのオペレーションはそもそも必要ないと理解)

- クエリ項のフラット形式は、以下のような一連のレジスタ割当に相当する。
```
Xi = f(Xi1,・・・,Xin)
```
レジスタ割当の順序は「ボトムアップ」の順とする(つまりそのレジスタがサブタームの引数として使用されるよりも「前に」割当られる)。

  フラット形式におけるクエリ項の例 p(Z,h(Z,W),f(W))は以下:
```
X3=h(X2,X5),X4=f(X5),X1=p(X2,X3,X4)


(訳注:サブタームの定義が順番として先にくるように、レジスタ割当の順番がボトムアップに調整されている。)
```

```
   （訳注:ただし、変数レジスタのインデックスがそれによって入れ替わったりはしていない。
    　・まずここで問題となるのは、データ代入命令の実行順であり、これが保証できなければ、レジスタ値の整合性が保証できなくなる。
    　・一方で変数レジスタの番号は(そのことに影響されることなく)トップダウンで参照され、かつ最小限のリソースとなるように
    　（使用する変数レジスタの番号の最大値が最小になるように）調整することが可能なので、それによってレジスタ付番の順番
    　を決めているということができそうである。）
    (少なくともX1に一番外側の項を割当るという点は維持される必要がある:後のユニファイ処理のために)

（考察: これを実現するためには、まず、構文解析木？を作ったうえで、その木構造を、縦型探索の方式で、
ルートから下へ、左から右へ順次進み、リーフノードに突き当たったものから順番に、レジスタに割り当てるようにしたら、
所定の動作をさせることができるのではないか？その時に、木構造のルート側のレジスタ割り当てが、
全ての下位構造の割当が終わった後に、一番最後に割り当て処理をするようにすればよい、ということではないだろうか）
```

```
（注釈: WAMのレジスタ割当における「ボトムアップ」の動作を考察すると以下のようになると考える
　①まず、木構造をルートから、縦型探索の要領で左から純に leaf まで到達させる。
　②leaf まで到達したら、１つ手前の node 戻る際に、まず leaf を処理(コードを出力)し、その後で node を処理する。
    もしも、木構造の構造が、同じ深さでない場合、一方は leaf だが、もう一方は node である、という場合もあるだろうが、
    その場合は、最左の要素を処理し(leaf ならば これを処理して終わる)、次にその隣の要素を処理(node ならば、
    更に木を下に潜っていくが、結局 下部構造を出力したあと、自分自身(node) を処理して終わる)し、
    そして、最後に node を処理して終わらせる。

　このように、「ボトムアップ」なのだが、まず縦型探索を行って、それを戻る時に、下から順に処理してゆくと考えるとよいので、
　「トップダウン-ボトムアップ」あるいは、「ボトムリターン」という言い回しの方が理解しやすいかもしれない。
（これに対して、完全な「ボトムアップ」とは、最下層の leaf が自己組織化して構造を作り上げていくようなイメージであろうが、
 WAMはそういう動きではない）
)
```

### 【トークナイズド形式】
フラット化したクエリ項を左から右に読み込むことで、
クエリ項 Xi = f(Xi1, ・・・, Xin) をトークナイズし、

Xi=f/n, Xi1, ・・・, Xin のようなシーケンスに変換する。

トークナイズされたクエリ項 p(Z,h(Z,W),f(W))は、
以下のような、9つのトークンに変換される。
```
    1: X3 = h/2,（訳注: 原文ではh/3だが、明らかに間違いと考え訂正）
    2: X2,
    3: X5,
    4: X4 = f/1,
    5: X5,
    6: X1 = p/3,
    7: X2,
    8: X3,
    9: X4.
    (訳注: 順番は、フラット形式と同じ。その上で、ファンクタ表記に変換されたり、引数部分が
    単に変数の列挙に変換されたりしている。HEAPに格納することを念頭に置いた表記であろう。)
```
<br><br>
処理対象となるトークンには、次の３種類がある。
1. 構造体ファンクタに割り付けられた、レジスタ
2. 読み込みストリーム中、(その時点で)初めて登場する、レジスタ引数
3. 読み込みストリーム中、既に登場したことのある、レジスタ引数

### 【M0 クエリ命令: M0 query term instructions】
前記3種類のトークンは、それぞれ以下の命令に対応する
1. put_structure f/n,Xi

    HEAPに新規の STR セルを PUSHし、そのセルを、割り当てられたレジスタにコピーする
2. set_variable Xi

    HEAPに新しい REF セルを PUSHし(まだ未参照なので 値はそのセルのアドレス自身を格納)、そのセルを、割り当てられたレジスタにコピーする(つまり HEAPの値→レジスタ へコピー)
3. set_value Xi

    HEAPに新しいセルを PUSHし、そこに、レジスタの値をコピーする（つまり レジスタの値→HEAP へコピー）


### 【HEAPレジスタ H】
レジスタ H には、HEAP領域中「次の」未使用セルのアドレスを格納する

＜各マシンコードの擬似コード＞
```
  put_structure f/n,Xi ≡ HEAP[H] ← <STR,H+1>;
                         HEAP[H+1] ← f/n;
                         Xi ← HEAP[H];
                         H ← H + 2;

  set_variable Xi      ≡ HEAP[H] ← <REF,H>;
                         Xi ← HEAP[H]
                         H ← H + 1;

  set_value Xi         ≡ HEAP[H] ← Xi;
                         H ← H + 1;
```
```
  (L0言語クエリ 「?-p(Z,h(Z,W),f(W))」のM0仮想マシンコード)
  put_structure h/2,x3    %  ?-X3 = h
  set_variable X2         %          (Z,
  set_variable X5         %             W),
  put_structure f/1,x4    %    X4 = f
  set_value X5            %          (W),
  put_structure p/3,x1    %    X1 = p
  set_value X2            %          (Z,
  set_value X3            %             X3,
  set_value X4            %                X4).
```
```
  (前述のトークナイズ形式を基本的には素直に命令列に変換している。
    一方では、変数が既に出現したかどうか記憶するなどして 変数が再度現れる場合を判別し、 set_value を選択している。
  )

 （気づき: レジスタは一番外側の項がX1に割りあたるような順(トップダウンの順かな？)でセットしたいが
  HEAP上では、ボトムアップに、一番外側の項が、最後尾の領域に記憶されるようにしたいのではないだろうか？
  そうすれば、(ボトムアップな順番に記録することになるから）HEAP上の参照関係の記録順序が、間違いなく維持されるから
  参照すべき記憶領域が、まだ存在しない、という事態が回避できるからね。
  これは変数が複数現れたときに(HEAP上に既に存在することが)重要になるのであろう。）

  (HEAP上で、木構造のデータの一種である一階述語論理の項を格納するためには、木構造の末端(leaf)から順次格納するように
　つまり、ボトムアップに、組み立てていかないと、参照関係を適切に維持するのが、難しい。
　最終的に、一番外側の項を格納する段階で、木構造上の子要素が、すべて既に格納され、木構造上の親からみて全て参照できるように
　HEAP上のアドレスが確定していることが望ましいし、効率もよいだろう：
　　そうでないと、一度その要素がどの格納領域のアドレスに格納されるべきか、計算した上でないと格納できないか、
　　場当たり的な中継記憶領域を設けて辻妻を合わせるしかなくなるだろう
　　　(まあ、コンパイル時に決めることができる事項であり、かつてのようにコンパイル時のメモリ効率を追求する要件は
　　かなり緩和されているのでこの格納構造以外の方法も考案できるだろう。将来的な都合で変更も可能な事項と考える。)
  )
```
```
<<<< このコマンドを実行した結果HEAP上にどう記録されるか、実際に机上計算してみよう。
   0|STR|1|_
   1| h/2 |
   2|REF|2|
   3|REF|3|
   4|STR|5|_
   5| f/1 |
   6|REF|3|
   7|STR|8|_
   8| p/3 |
   9|REF|2|
  10|STR|1|
  11|STR|5|
ああ、冒頭のHeapの例と全く同じになるのか・・・
レジスタの値も書いてみると・・・
X3 = <STR,1>
X2 = <REF,2>
X5 = <REF,3>
X4 = <STR,5>
X1 = <STR,8>
・・・たしかに、Heapのデータの構築のために、レジスタを利用したんだな、ということがわかってくる。
たとえば、set_vale X4 では、レジスタの値を使って、 11|STR|5| がセットされることがわかる。
>>>>
```


### 【L0 プログラムのコンパイル】
```
(訳注: どうして queryを読み込んだ「後」にプログラムの話しを展開しているのか？
それは、WAMの動作として、まず ①queryをストアする(HEAP&レジスタ)、そのあと ②これに対してプログラムをマッチさせる
という動作の順だからである。
（これは、データベースに対して query を投げてマッチングさせるという先入観からすると全く逆の動作に見えるので留意されたい。)
もう一点はそれは、未だ CODE_AREA が用意されていないからであろう。CODE_AREAは L1で用意される。)
```

プログラム項 p をコンパイルするとき、以下の前提を置いている。

　　（このプログラム項 p が呼び出されるときには）クエリ「 ?- q 」が、あらかじめHEAP上に格納されており、レジスタ X1 にはそのアドレスが格納されている。
 ```
  (訳注: ・・・X1 にアドレスを格納していることが、明確にプログラム側の足掛かりになっている。）
  (もう１点指摘すると、X1には一番外側の項が割り当てられるが、一番外側の項だけは、項の数が確実に一致する前提に立てる。
    このため、機械的に項に対してレジスタを割り当て可能であることが保証されている。
  　そこから先のサブタームになると、(変数になったり、ファンクタだったりして)必ずしも双方の項の構造が一致しているわけではない。
  )
```
そこで、L0プログラム項のためのコードについて2つのモードを使用する
- READモードでは、HEAP上のデータに対するマッチのために使用される
- WRITEモードでは、クエリ項とまったく同じように、項がHEAP上に構築される
    `（訳注: 変数や構造体を作成するために使用される）`

これに対応する p のコードは以下からなる
- レジスタX1にすでに格納されている、項構造について(つまりqの項構造について)、pの構造体としてのファンクタと対応づけが可能なものはすべてマッチさせる。
- HEAP中にあるクエリ項 ？-q の中に、未束縛のREFセルが見つかった場合、
これと対応づけ可能な p の部分項を(パターンマッチ可能な)一つの適用例(exemplar)とする、そしてこれをもとにHEAP上に新規に項を作り、これをバインドする。(訳註:これは、つまりクエリ文中の変数に対する「答え」を形成しようとしているのである)

### 【Tokenizing L0 program terms】
変数レジスタは、先程と同じように割当てられているとする。
例えば プログラム項 p(f(X),h(Y,f(a)),Y) の場合は、以下のようになる。
```
    X1 = p(X2,X3,X4)
    X2 = f(X5)
    X3 = h(X4,X6)
    X4 = Y
    X5 = X
    X6 = f(X7)
    X7 = a.
```
```
>>>>>(対比のために、先の記載を再掲載)　p(Z,h(Z,W),f(W))
    X1 = p(X2,X3,X4)  :最も外側の項
    X2 = Z            :変数Zに割り当てられる変数レジスタは、直近の使用可能なインデックス(index=2) 番号のレジスタから選ばれる
    X3 = h(X2,X5)     :複数出現した変数(W)は同一のレジスタ(X5)が割り当てられる
    X4 = f(X5)        :同上
    X5 = W.
    このように対比してみると、X1は(変数も対応させることができるので)対比可能だが、
    それ以降はそれぞれの構造の違いが出てくるのでレジスタの対応関係は異なってくる。
    （ただ、Query側は、HEAPに記録されているのだから、レジスタのレベルで対比できなくても困らないと考える）
<<<<
```
一方で、今回(プログラム)のフラット化フォームは、(クエリのフラット化フォームと異なり)「トップダウン」の順とする。
なぜならば、HEAP上のクエリデータは、あらかじめ利用可能と想定されているからである。
（たとえフォームが、未束縛REFセルのみであったとしてもである）

最終的に、プログラム項 p(f(X),h(Y,f(a)),Y)は、以下のようにフラット化される:
```
  X1 = p(X2,X3,X4),
  X2 = f(X5),
  X3 = h(X4,X6),
  X6 = f(X7),
  X7 = a.
```
なお、次工程のトークナイズに関しては、前述と基本的に変わらない。



### 【 M0 プログラム命令】

プログラムトークンは、3種類の命令からなる
1. get_structure f/n,Xi
2. unify_variable Xi
3. unify_value Xi

それぞれ以下の状況に対応する　　
1. 構造ファンクタに関連づけられるレジスタ引数の場合
2. 最初に登場するレジスタ引数の場合
3. 既に登場したことのあるレジスタ引数の場合

```
L0プログラム「p(f(X),h(Y,f(a)),Y).」の仮想マシンM0のマシンコード
  get_structure p/3,x1   %  x1 = p
  unify_variable x2      %        (X2,
  unify_variable x3      %            X3,
  unify_variable x4      %               Y),
  get_structure f/1,x2   %  X2 = f
  unify_variable x5      %        (X),
  get_structure h/2,x3   %  X3 = h
  unify_value x4         %        (Y,
  unify_variable x6      %           X6),
  get_structure f/1,x6   %  X6 = f
  unify_variable x7      %        (X7),
  get_structure a/0,x7   %  X7 = a
```
```
(考察：先のクエリの場合は、ボトムアップに命令が組み立てられていた（最初は、h/2 の格納から始まり〜p/3の格納で終わる）
　　   プログラムの場合は、トップダウンに命令が組み立てられている
      これは、実際のユニファイが実行される順番としては、トップダウンが都合がよいからである。）
(むしろ、トップダウンに呼び出されることを想定しつつも、HEAP上に構造データを効率よく格納するために、ボトムアップ
にセル上に格納する方式を編み出したのが、極めて素晴らしいのではないだろうか・・・)
(追記: プログラムコードは、実際には、コンパイルした後(L1以降は CODE_AREA に格納される)、
クエリから呼び出されると直ちに順に実行されるものであり、HEAPに格納するためのものでない(一時記憶領域がないと
ボトムアップにはできない)ので、むしろ、トップダウンに実行できる必要があるということか。
（呼ばれる側はボトムアップに格納され、呼ぶ側はトップダウンに実行される。これでぴったり合うということか
　・・・HEAPの役割は、あくまでもクエリのデータ格納域+ユニフィケーションを実行するパターンマッチ
　　　　のための領域であり、そして最終的には実行結果の結果を格納し、解答を得るための領域であるとみなすべきだろう)）
```

```
(対比のために先ほどの記述を再掲載)
<<<< このコマンドを実行した結果HEAP上にどう記録されるか、構成してみるのもよいであろう。
p(Z,h(Z,W),f(W))
   0|STR|1|
   1| h/2 |
   2|REF|2|Z
   3|REF|3|W
   4|STR|5|
   5| f/1 |
   6|REF|3|W
   7|STR|8|
   8| p/3 |
   9|REF|2|Z
  10|STR|1|
  11|STR|5|
ああ、冒頭のHeapの例と全く同じになるのか・・・
レジスタの値も書いてみると・・・
x1 = <STR,8>
x2 = <REF,2>
x3 = <STR,1>
x4 = <STR,5>
x5 = <REF,3>
>>>>
【コメント: 以下の動作の詳細な定義は、この後の本文記述で説明されているので、説明内容が不明でも心配しなくていい】
p(Z=f(X),h(Z=f(X),W),f(W))
p(f(X),h(Y,f(a)),Y)
(Heapポインタは H=12 にセットされているとする)
get_structure p/3,x1    |  deref(x1) => <STR,8>, HEAP[8] == p/3, S = 9, mode = READ
unify_variable x2       |  x2 = HEAP[9]  =<REF,2>, S = 10　（これって、各レジスタに q の第1〜3引数を再ロードしている動きだね）:Z
unify_variable x3       |  x3 = HEAP[10] =<STR,1>, S = 11　（同上）:h(Z,W)
unify_variable x4       |  x4 = HEAP[11] =<STR,5>, S = 12　（同上）:f(W) (あっ、単なる再ロードではなく、事実上 Yとユニファイされているということなのか。。。 Y=f(W)ただ、やっていることは再ロードでしかない。。。巧妙？ということか？ X4は、はなからYとみなしているが、再ロードの動作により、Y=f(W)と同じとみなせるのか？f(W)のことははなから気にしていなくて、X4はYだ、とコンパイルしているということか）
get_structure f/1,x2    |  <REF,2> = deref(x2), STORE[2]==<REF,_>, HEAP[12] =<STR,13>, HEAP[13]=f/1, bind(2,12)...なので、x2=<STR,13>かな, H=14, mode = WRITE
unify_variable x5       |  HEAP[14] =<REF,14>, x5= HEAP[14] =<REF,14>, H=15, S=4 (#注 qではx5は変数Wがセットされていたが、上書されて変数Xがセットされている（大丈夫か？）（大丈夫。そもそも x1 しか内容保証していないと言える。それでも、上記再ロードでqの引数は辿れるようになっている。Wは、この時点では、明示的にはレジスタにセットされていないということかな？）)
get_structure h/2,x3    |  <STR,a=1> = deref(X3), HEAP[a=1]==h/2,  S = a+1=2, mode = READ (h/2 のユニファイが成功し、h/2の各項(subterm)のマッチングへと下降してゆく)

p(f(X),h(f(X),W),f(W))
p(f(X),h(Y=f(W),f(a)),Y=f(W))
　　　　　　　　　　　　　　　　# X4(=f(W))を、S=2(=f(X))とユニファイする
unify_value x4          |  unify(X4,S=2) #注 S=2 は、HEAP上のaddress=2 を差し もともと 2|REF|2|Z であったが bind(2,12)で上書きされ、<STR,13> =f(X) に差し替えられている
                           --> unify(<STR,5>,<STR,13>) --> (f/1 == f/1 となったので・・・）unify(<REF,3>,<REF,14>)
                           --> ・・・bind(3,14) つまりbind(W,X))かな で、HEAP[3]=<REF, 14> S = 3
p(f(X=W),h(f(X=W),W),f(W))
p(f(X=W),h(f(W),f(a)),f(W))
　　　　　　　　　　　　　　　　# ①h(_,f(a))のf(a)部分をユニファイする前に、まず、h(_,W)のWを先にX6とユニファイし。。。
unify_variable x6       |  X6 = HEAP[S=3] =<REF,14> S = 4  #注 ・・・ここで、もともとX5にセットされていた変数Wが、
                                                           #（X5が潰されてしまったにも関わらず・・・）ユニファイされている。
                                                           # それを救っているのはS=3である（h/2 のsubtermの２つめの項がS=3である）
                                                           # このしくみで、X5が上書きされても、その時記憶されていたアドレス(X5 = <REF,3>)
                                                           # を辿れるようになっているというべきか
                                                           # 理屈でいうと、X1に直接紐づくトップレベルの項に対応するレジスタ（今回の例では X2,X3,X4)
                                                           # さえ上書きされなければ、
                                                           # ユニファイの結果により、HEAP上のアドレスを辿ることができるので、それ以降のX5〜のレジスタは上書き
                                                           # されても、困らないということであろうと考える。
                           # ②その上で、X6とユニファイして 得た W と、f(a)とをユニファイしてゆく順番になっている。。。（構造化されている部分は、「フラット化」により
                           # 一旦一時変数を中継した形で、構造を表現するように表現しなおされている。）
                           （フラット形式にしたことにより、このような手順が「可能」になっていると言うべきか）（より構造的になっている方が後からユニファイする順番になっているのね）
get_structure f/1,x6    |  <REF,14> = deref(X6), STORE[14]==<REF,_>, HEAP[H=15] =<STR,16>, HEAP[15+1=16] =f/1, bind(14,15) H=17, mode = WRITE
unify_variable x7       |  HEAP[H=17] = <REF,17>, X7 = HEAP[17] =<REF,17>, H = 18 #注 変数を中継するので冗長に見えたが、ここまで見てゆくと
                                                                                  # あらゆるケースでユニファイを成立させるために必要な手順と思えてくる
get_structure a/0,x7    |  <REF,17> = deref(X7), STORE[17]==<REF,_>, HEAP[H=18] =<REF,19>, HEAP[19] = a/0,bind(17,18), H=20, mode = WRITE

p(f(W=f(a)),h(f(W=f(a)),W=f(a)),f(W=f(a)))
p(f(W=f(a)),h(f(W=f(a)),f(a)),f(W=f(a)))


この仕組みの巧妙さについての気づき
   ①あらかじめ、同一述語内の同一の変数は、同一アドレスにセット済みであること(コンパイル時にパターンマッチが終わっている)
   ②上記各instractionでは、その項の値が、構造体か？変数か？あらかじめ特定した上で、instractionが構成されていること
   （このため、各instraction処理実行のタイミングでは、型判定処理などは行わなくてよい）
   ③フラット形式にした後にユニファイすることで、構造データのあらゆるバリエーションに、機械的なプロセスで対処できる
新たな疑問
   ・HEAPが上書きされてしまったら、どのように、queryの解を返却するのだろうか？
   （どうやら、クエリ中の変数が格納されるレジスタの位置は、ユニファイ後も維持される様なので、コンパイルの途中で、
   　どの変数がどのレジスタ番号にセットされたか？その変数名は何か(Z? W?)を別途記録することさえできれば、答えを返すのは難しくなさそうだし、
   　そこの部分の実装だけであれば、難しいことは何も無いように思われる。ので、実際にクエリの答えを返却する方式は別途独自に実装すればよいと、
    仮に納得しておこう・・・(この実装は、実際は dereference そのもなので、ただプロンプト時に query中の変数をリストアップして call すればよいだろう)）

追加・変更された HEAP 領域データ
   0|STR|1|
   1| h/2 |
   2|STR|13|binded
   3|REF|14|binded
   4|STR|5|
   5| f/1 |
   6|REF|3|
   7|STR|8|
   8| p/3 |
   9|REF|2|
  10|STR|1|
  11|STR|5|
  12|STR|13|
  13| f/1  |
  14|STR|16|binded
  15|STR|16|
  16| f/1  |
  17|REF|18|binded
  18|REF|19|
  19| a/0  |



実行後のレジスタの状況
X3 = <STR,1>
X2 = <REF,2>
X5 = <REF,12>
X4 = <STR,5>
X1 = <STR,8>
X6 = <REF,3>
X7 = <REF,14>

Zは <REF,2> なので、デリファレンスすると、Z=f(f(a))
Wは <REF,3> なので、デリファレンスすると、W=f(a)
クエリに解答するには、Z=<REF,2> W=<REF,3>を何らかのかたちで覚えておく必要があるとおもう。
```


### 【デリファレンス】
変数のバインドが繰り返されると、参照関係のチェインが形成される。

デリファレンスは 関数 deref により実行される。
この関数は、与えられた格納アドレスを元に 参照可能なチェインを辿り、
辿った先が、最終的に 未参照のREFセル か、あるいは 具体的な値(non-REFセル)に行き当たると、このアドレスを返却する。

＜デリファレンスの擬似コード＞
```
function deref(a: address): address;
  begin
    <tag,value> ← STORE[a];
    if(tag = REF) ∧ (value ≠a)
      then return deref(value)
    else return a
  end deref;
```
<br><br>

### 【READ/WRITE mode】
ユニファイ命令は、状況に応じ2つのモードで動作する。
```
  (訳註: 項(term)を、HEAP内でマッチさせるか、もしくはHEAP上にビルドするかの、いずれかの目的によってモードを切り替える)
  (訳注: ユニファイしたときに、相手(pからみてq:※)が変数だったら、WRITE(で、こっちも変数をHEAP上に作るか構造データをHEAP上に格納する).
  　相手(pからみてq)が符合する構造体であったら、READ(で、さらにユニファイをつづける).)
```

- ビルド(WRITE mode)では、２つの set クエリ命令(後述)を実行する。
- マッチ(READ mode)では、
    HEAPからのデータを対応する位置にある項のデータとして認識できるか読み込み、
    これが成功した場合は、先に進む(proceeding)。さもなければ、失敗とする。
```
    (脚注 pからみてq:※ なぜそう言い切れるかというと、各命令は、p側から呼び出しているのであり、p側はあらかじめコンパイルされており、
    自分自身が変数か構造体かあらかじめ分かっており、そもそも、分かっているからこそ、get_structureなどの呼び出しができるからである。
    pからみて不明なのは、qがどういう構造なのか？であり、
    それは、qが投入されてはじめて判明することであり、あらかじめ想定することができない。)
```

### 【サブターム・レジスタ S 】
レジスタ S には、READ モードでマッチされた「次のサブターム」のアドレス(HEAP領域)を格納する。<br>
(訳註: S は WRITE モードでは使用されない)

```
(訳註: Sとは、get_structure 命令に続く unify_XXXXのために、サブタームを順番に参照できるようにするためのもの
と考えてよさそうだ。
  　ちなみに、サブタームは、以下の例のように順次隣接して呼び出されることが保証されているので、Sは単なるインクリメントで
  　対処できるようだ。
    前述の命令を抜き出すと、
    get_structure p/3,x1
    unify_variable x2       |  x2 = HEAP[9]  =<REF,2>, S = 10
    unify_variable x3       |  x3 = HEAP[10] =<STR,1>, S = 11
    unify_variable x4       |  x4 = HEAP[11] =<STR,5>, S = 12
    ここでは p(x2,x3,x4)の、それぞれのサブタームとなる、x2,x3,x4を順に参照するために、Sを使用している。
    ・・・それなら、unify_variable 命令に、Sに当たるアドレスを付属させればいいじゃないか？とも考えるが、
    そうかもしれない、、、が、readモードとwriteモードで動きが異なるので、writeモードでは使用することのない、
    Sのアドレスを付属させない方針にしたということだろう。

    もう一つの理由として、(プログラム側の)コンパイル段階では、set_structure の段階で、
    readモードとなるのか wirte モードとなるのかは決定できないということがある。
    決定するのは、クエリを投入する段階なので、そこをコンパイル段階で表現するためには、別の制御の仕組み
    （例えば条件分岐を書けるようにして両方のパターンを書くようにするなど）が必要になってくるということもあろう。
    その上で、WAMでは read/writeモードの方式でやる決断をしているのだと考えよう。

    さらに、よく考えると、Sに格納すべきHEAPのアドレスは、あらかじめ決められないので、
    コンパイル時には決定できない。とすると、やっぱりレジスタSを用意する必要があるか。

  )
```

get_structure f/n,Xi 命令では、(q との対比結果に応じて) Mode をセットする:

もしも デリファレンス deref(Xi) の結果が・・・
- REFセル(未束縛変数)である場合は、`(訳註: これは、p側は構造体f/nなのに対し、q側は変数であった、などという場合にあたる)`
新しい STR セル(f/nをポイントしている)をバインド(後述)し、HEAPにPUSHする。
そしてModeを WRITEにセットする。

- そうでない場合は、
    - STRセルが ファンクタ f/n に対応している場合は、レジスタ S に このファンクタセルの次のHEAPアドレスを格納し、Modeを READ にセットする。
    - そもそもSTRセルでないか、そうであったとしても、ファンクタが f/n と一致しなかった場合は、このプログラムの結果を失敗とする。

  ＜get_structure の擬似コード＞
 ```
  get_structure f/n,Xi ≡　addr ← deref(xi);
                            case STORE[addr] of
                              <REF,_> : HEAP[H] ← <STR,H+1>;
                                        HEAP[H+1] ← f/n;
                                        bind(addr,H);
                                        H ← H+2;
                                        mode ← WRITE;
                              <STR,a> : if HEAP[a] = f/n
                                        then
                                          begin
                                            s ← a + 1;
                                            mode ← READ;
                                          end
                                        else fail ← true;
                              other    : fail ← true;
                            endcase;
```

#### unify_variable Xi:
- READ モードでは、アドレスS(HEAP領域)を参照して、その値を Xiレジスタにセットする。
- WRITE モードでは、新たな未束縛REFセルをHEAPにプッシュし、この値をXiレジスタにもセットする。

#### unify_value Xi:
- READ モードでは、Xiレジスタの値と、アドレスS(HEAP領域)にある項をユニファイする。
- WRITE モードでは、新セルをHEAPにプッシュし、そこに Xiレジスタの値をセットする。

各モードとも Sは1つ増分される。

＜unify 命令の疑似コード＞
```
unify_variable Xi ≡ case mode of
                      READ  : Xi ← HEAP[S];
                      WRITE : HEAP[H] ← <REF,H>;
                              Xi ← HEAP[H];
                              H ← H + 1;
                    endcase;
                    S ← S + 1;

 unify_value Xi   ≡ case mode of
                      READ  : unify(Xi,S);
                      WRITE : HEAP ← Xi;
                              H ← H + 1;
                    endcase;
                    S ← S + 1;
```

（訳註: ここで、論じられている mode であるが、これをどのように実現するのか？については具体的な記載がない。
最初に思いつく実装は「MODE レジスタを用意する」ということだが、他の文献をみても、具体例に触れている
記載がほとんどみられない。１件だけ MODEレジスタを用意した解説を発見したので、レジスタで実装することを想定する。
ただ、CPUなどで mode を表現する手段が別途組み込まれているケースはあるのだろうか？このあたりは
不案内なのでよく分かっていない。）

### 【変数のバインド】
バインドは２つの格納アドレス間で実行される（この場合、少なくとも片方は 未参照セルであるとする）。

当面は以下の実装とする:
- 片方が未束縛セルの場合には、もう一方をバインドする。
  　（具体的には、未参照のREFセルのデータフィールドに他方のセルのアドレスを上書きする）
- 双方とも未参照のREFセルの場合には、
    （どちらでもバインド可能なので）任意でどちらかのアドレスをバインドする。

#### NOTE:
バインドは 循環参照となる可能性があるため、これを防止するためには occures-check テスト等の実装が必要となろう。

＜unify関数の疑似コード＞
```
procedure unify(a1, a2: address);
  push(a1,PDL); push(a2,PDL);
  fail ← false;
  while not(empty or fail) do
  begin
    d1 ← deref(pop(PDL)); d2 ← deref(pop(PDL));
    if d1 ≠ d2 then
    begin
      <t1, v1> ← STORE[d1]; <t2, v2> ← STORE[d2];
      if(t1 = REF) or (t2 = REF)
        then bind(d1, d2)
        else
        begin
          f1/n1 ← STORE[v1]; f2/n2 ← STORE[v2];
          if (f1 = f2) and (n1 = n2)
          then
            for i ← 1 to n1 do
            begin
              push(v1 + i, PDL); push(v2 + i, PDL);
            end
          else fail ← true
        end
     end
  end
end unify;
```

```
(訳註  unify関数の動作の概略を記述すると
  ・ユニファイ対象の両者のアドレスを、プッシュダウンリストにプッシュ
  ・whileループに入る
    - まず、プッシュダウンリストをプルして、両者のアドレスを読み出す
    - 両者を比較して、片方が変数(REF)ならば、バインド処理をして終了
    - 両者とも同じファンクタ(f1/n1 = f2/n2)であるstructure だった場合は、
      ・structure の中の各項（通常は複数ある）を、プッシュダウンリストにプッシュ
    ループに戻る
  ・プッシュダウンリストが空になったら処理終了
  （気づき:構造体の比較を行う時に、中身を見る前に、ファンクタf/nのレベルで比較して判断している
  　　　　　ところが効率が良いと思った)
)
```

```
注記:
我々は、STORE[a]という表記を、address a に格納されたデータセルの値の意味で用いる。
(Heapでも Xレジスタでも、あるいはその他ここで述べられていないグローバル構造体も含めて、
項を格納できるデータセルであれば何でも指すものとする）、一方で、HEAP[a]のように、
特に実装上の特徴を強調したい場合には、より具体的な表記を用いるものとする。(wam_bookより）
```

```
(考察:今後スタックへの参照も行うことになるが、その場合（記憶領域のエリアを区別せずに） address だけを頼りにアクセスするように
  処理を記述してゆくようになるようである。これは一種の抽象化と言っていいのであろうか。。。）
```

　
## 【L1言語定義: Language L1】
  L1では、これまで一括りにしてきた「項」を、以下の２つに区別していく
  - アトム(述語として定義された項)
  - 項(述語の引数)

### 【L0の拡張】
#### 構文(Syntax)

（L1は）L0とほとんど同じだが、L1では、プログラムは一階述語論理のアトムの集合とし、
各アトムは最大で１つのファクト述語まで定義できるものとする。
`(訳註:L1の段階では、連言表現もできないし、バックトラックもできない)`
#### 構文の意味（Semantics）
クエリの実行により、与えられた単一化式を解くことのできる適切な定義（ファクト）と対応づける（ユニファイする）。
それができない場合は、呼び出された述語に該当するものがないので失敗とする。
<br><br>

  L1の命令セットは、L0の命令セットを包含する。

  M1の場合、コンパイルされたコードは コードエリア(CODE領域)に格納される。
  コードは一まとまりの命令の列であり、(これを呼び出す便宜のため)ラベル付けされる。
  各命令はopコードおよびそれに続くオペランドの列から構成される。

  アドレス a (すなわち CODE[a])に格納された命令のデータサイズは、関数 instruction_size(a)で与えられると仮定する。

  各ラベルは、コードエリアへの シンボリックなエントリポイントであり、
  制御を適切なコードにラベルづけするために、命令中のオペランドとして使用される。
  それゆえ（コンパイルした命令列を指定するためのキーとしての）手続き名そのものをヒープ中に格納する必要はない。
  `(訳註 クエリ中の引数データをヒープに格納したら、通常次のアクションとして call(ラベル名を指定)命令 を実行することになる)`


###  【制御命令】
　　基本的に各命令はシーケンシャルに実行されるものとする。

####  【プログラムレジスタ P】
レジスタPには「次の」実行すべき命令のアドレスを保持する。
`(訳註:これは、コードエリア側のポインタ情報を保持していることになる)`

  通常Pは instruction_size(P)の値でインクリメントされる（失敗が発生しないかぎり）。

  （一方で）いくつかの命令の中には、シーケンシャルな実行をブレークしたり、
  あるいはシーケンスの最後に いくつかの他の命令にジャンプするものがある。
  これらの命令を「制御命令」と呼び、レジスタPを特別な方法でセットする。

  M1で定義される制御命令は以下:
- call p/n ≡ P ← @(p/n);
  - @(p/n)は、p/nに対してラベルづけされた命令に対するコードエリアのアドレスである。
  - 手続き p/n が定義されていない場合、処理は失敗し abort する。
- proceed
  - 命令シーケンスの終了を意味する(L2以降で拡張されるが、L1では何もしないので 単なる標識 程度の意味しかない)。<br>
（訳註: ただし、レジスタ P を元に順次命令をプログラム実行してゆくときに、proceedにより、プログラムの終端を判別することが可能になる。
proceedがプログラムの最後にないと、別のプログラムの先頭を読み込んでしまい。プログラム実行が破綻する。
そう考えると、プログラム実行の要諦の１つとも言える。)


### 【引数レジスタ】
L1では、ファクトtermとクエリtermとのユニフィケーションは必ずしも１回とは限らず、複数の単一化式を一度に解くことになる。

M0では、X1レジスタには必ずルートとなる項がセットされていたが、
M1では(上記の意味でのX1レジスタは省略され、代わりに)、n個のアリティを持つ述語の n個の引数が、レジスタX1,・・・,Xnに自動的に割り当てられる(これを引数レジスタと呼ぶ)。

```
（訳註1:・・・つまり、M0でやっていた、X1レジスタへの格納は廃止し、その代わりに引数部分を直接割り当てるように
　変更しよう、と言っている（これでレジスタが１個節約できる）。
　かつてのX１〜Xn+1に割当たっていた項そのもの+引数の割り当ては、M1では、
　X1-Xnに引数のみ割り当てるようになる。そして、それをA1-Anというように呼び方を変更しようとしている。

　そもそもM0においてX1に項そのものを割り当てて、これを参照させるのは、X1参照->各引数を参照する動作は(よく考えれば)冗長であり、
　直接各引数を参照させても何も不都合は起きないのだから、省略できるではないか？ということである。
　(そのあと call f/n でコードを呼び出すと、コード側で、引数を読む 命令が実行されるが、
　そのとき、引数の数は、コード側で知っているという前提に立てる。実際には、 call f/n としたときの、「n」
　はクエリ投入時に指定されるのであり、そのとき実際に 引数n個の f が存在するかは、call してみないと分からないということだが、
call できれば、引数 n との噛み合わせはピッタリ符号するようになるので、間接的に、call f/n で引数がnであることを伝えて
いると言えなくもない)
）
```
```
（訳註2：・・・もう１点、
　p/3の引数について、構造体が含まれる場合は、M0では、参照変数を作って(フラット化して）、最後に呼び出すように
　していたが、p/3のレベルの引数については、そうする代わりに、A1〜Anに直接割り当てるように変更している。
　①変数の場合は、これまでどおりレジスタに割り当てる（ただしAxに)
　②構造体の場合は、参照変数を作らずに、Axに割り当てる
　という動きになっているが、具体化は結構悩ましい。
　・・・それから、P/3のレベルでは、ボトムアップの規則が崩れているようにみえる(これは、P/3をHeapに格納することを省略しているので、
　理屈的には問題ではないだろうが、さらに、その下位構造では、やはりボトムアップに作り上げる必要があるだろう:
それらは結局Heapに格納するのでボトムアップに構築するしかない、というのが結論である。。。
このあたりの切り替えが、どうすればよいか、どうすれば機械的に処理できるか？が悩ましい。
　順序を気にしなくてよいならば、p/3まわりに処理だけを、処理変更するようなコードで乗り切れるような気がしなくもないが・・・)）
```
```
（訳註3:・・・ボトムアップにやっていると、最後にp/3にまで到達した段階で、Axであることが後からわかるような感じになり、コードの書き換えを
　するような感じになるような気がしてくるが、どうするか。。。まあ、コードの書き換えでもいいような気がしてきているが、
  p/3のコードは疑似的に作っておいて、p/3に付属するX1,X2,X3を、あとからA1,A2,A3にして、
  なおかつp/3のstructureコードは削除し、p/3の引数コードは、変数に関するものだけを残し
  あとは削除する、、、というふうにすると、命令の順序は忠実でないが、一応動くものができるような気がする）
```

今後引数レジスタを指す場合は、XiではなくAiと表記し、（引数レジスタの）i番目が、（述語の）i番目の引数を保持していることとする。

またXiという表記は、引数レジスタとしては使用しない（NOTE:これは、単に名前づけの問題であり AiとXiは事実上同じものである。）

```
（訳註：この引数レジスタという考え方が、WAMの高い性能を支えるアイデアのひとつであり、
 クエリの引数が、必ずレジスタ群の先頭部分に固定的に配置されることにより、
 サブゴールへの引数渡しが省略できる(レジスタを直接参照させるこということか）メリットがあるとのこと
 （外部サイトによる情報）
 ）
 ```


たとえば、 アトム p(Z,h(Z,W),f(W))について、M1では、レジスタを以下のようにアロケートする。
```
        A1 = Z
        A2 = h(A1,X4)
        A3 = f(X4)
        X4 = W.
```
```
(考察: Wは、「X4」となっていることに注意。これは、クエリp(A1,A2,A3)としてみたときの、構造上のルートに位置する部分(それをArgumentといっている)
　　　　についてのみA1,A2,A3と割り振るのであり、構造上の下位部分(この例ではW)は、これまでどおり、Xiで表現するということである。
　　　　。。。そこまで、AとXを区別したくなる理由は今のところ承知していない
        -> 前述のとおりA1-A3は引数をそのまま引き継げて、かつレジスタ参照できるため、高速化に寄与しているため区別したい
        ということがだんだん分かってきた)
```
```
(考察:
以前のコードを併記すると、こうである(これだけみると、X1=... の行が削除されているだけ(それで、番号が１つ繰り上がっただけ)にみえる)。
＞＞＞＞＞＞＞
  X1=p(X2,X3,X4)
  X2=Z
  X3=h(X2,X5)
  X4=f(X5)
  X5=W.
＞＞＞＞＞＞＞
）
```

### 【引数命令】
  M1では、引数変数に対する制御命令が追加された

  L0と同様に、制御命令は「最初に出現した変数」か「再び出現した変数」かによって場合分けされる（query でも fact でも）。

#### queryでは・・・
  - i番目の引数位置において、変数が最初に出現したとき、
      新しい未参照 REF セルをHEAP領域にプッシュし、この値を引数レジスタ(Ai)にもセットする
  - その後に同じ変数が出現した場合は、引数レジスタ(Ai)の値を(HEAPに)コピーする

#### factでは・・・
 `(訳註: fact はここではじめて(唐突に)出現しているが、プログラムの意であろう）`
  - i番目の引数位置において、変数が最初に出現した場合は、（その変数レジスタに対して）引数レジスタAiの値をセットする
  - その後に同じ変数が出現した場合は、(その変数レジスタと）Aiとをユニファイする

＜引数命令の疑似コード＞
```
put_variable Xn,Ai ≡ HEAP[H] ← <REF,H>;
                     Xn ← HEAP[H];
                     Ai ← HEAP[H];
                     H ← H + 1;

put_value Xn,Ai    ≡ Ai ← Xn


(訳註: 上記のように 引数レジスタに特化した命令である put_value では、HEAPにデータを格納しなくなったが、
  これは最も外側の項である p/3 構造体そのものをHEAPに格納しなくなったことと対応しているのであり、
  (もしも、p/3をHEAPに格納するのであれば、３つの引数ともHEAPに格納しなければ、ファンクタの格納構造が崩れてしまう)
  一度、引数変数 Ai として put_variableにて HEAP に格納してしまった以上、
  もはや同じ Ai をHEAPに格納する必要性(あるいは制約)が無くなったということであると、理解した。)
  (なお、set_value は引き続き HEAPに変数を格納する。
    put_value が呼び出されるケースは、query 中の述語の引数が変数であり、かつその出現が２度目以上
    である場合に限定されるため、HEAPへの格納は冗長であると判断できるのである。)


get_variable Xn,Ai ≡ Xn ← Ai

get_value Xn,Ai    ≡ unify(Xn,Ai)
```

```
---
put_variable X4,A1    % ?-p(Z,
put_structure h/2,A2  %       h
set_value X4,         %        (Z,
set_variable X5       %           W),
put_structure f/1,A3  %              f
set_value X5          %               (W)
call p/3              %                  ). (<- CODEエリアに先にコードp/3が格納されている前提がある)
---
Argument registers for L1 query
?- P(Z,h(Z,W),f(W)).


(参考)上記命令にて構成される HEAP の状態
0|REF|0|
1|STR|2|
2| h/2 |
3|REF|0|
4|REF|4|
5|STR|6|
6| f/1 |
7|REF|4|

```

```
(考察:
・変数Zに対応する、X4とA1は同じ値が入っており、明らかに冗長のように見える（なお変数Wに対応する、X5は冗長にはなっていない）。
・一方で、put_variable の仕様としては、２つの引数(Xn, Ai)が必要になっているので、仕方がないのかもしれない。
・set_variable A1 が許容されるのであれば、上記の冗長性は解消できると思うが、どうなのだろう・・・
)
```
```
---
p/3: get_structure f/1,A1 % p(f
     unify_variable X4    %    (X),
     get_structure h/2,A2 %        h
     unify_variable X5    %         (Y,
     unify_variable X6    %            X6),
     get_value X5,A3      %                Y),
     get_structure f/1,X6 % X6 = f
     unify_variable X7    %       (X7),
     get_strucutre a/0,X7 % X7 = a
     proceed              % .
---
Argument registers for L1 fact
p(f(X),h(Y,f(a)),Y).
```

```
（所感: 同じ query と fact のはずなのに、L0とはだいぶ命令が変わっていて、特に、命令がコンパクトになっている。。。
一瞬見逃していた。。。）
（クエリ側を見ると、A1,A2,A3は新設している（そのため、例えば、Zは、X4とA1に両方同じものが入っているといった具合になっている）
ただ、使用しているレジスタの本数は5本で変わっていない。
割り当て方を最適化した結果のように見えるので、本数が同じなのは、たまたまかもしれない）
・・・よくよく考えてみると、引数レジスタの導入分は、純増であり、削減されたのは X1レジスタ分である
・・・（なお引数がサブタームの場合は、直接引数レジスタに代入されているので、レジスタ増減は 0 になっている）
・・・なので、引数レジスタの導入だけみると、使用レジスタは増加すると考えた方がよさそうである
(:クエリにて使用するレジスタ数は、①引数の数 + ②(引数に直接紐づかない）サブタームの数 + ③変数の数(ユニークにカウント)
で算出できそうである)
(:なお、プログラムによっては、（ユニフィケーションの過程で）追加でレジスタを使用する可能性もあるだろう。)

（発見したこと:
よくみると、p/3の第三引数に対する命令(get_value X5,A3)が唐突に挿入されているように見える（以前は、p/3最初の命令で、
早々に引数処理されるので、この位置で命令されることはなかった。）
ここに、この命令が入ることを、もういちど考え直すと、M1の処理においては、まず
①引数変数に関する処理はできるだけ早期に実施される。
②引数に構造体が来る場合は、当該構造体に対する割り当て処理は、引数レジスタの処理の一貫として早々に処理する
③しかし、この構造体の中に、さらに構造体が存在する場合は、これを後回しにする
というような優先順位になっているように思える。
そうでないと、第三引数 に対する命令(get_value X5,A3)が、この位置にくることへの説明が成り立たないと思う。

・・・別の見方もできると思ったので追記・・・
これは、p/3引数割り当てに対する「最適化」なのであり、最適化の方針としては、
①p/3構造体の格納の省略
②p/3構造体の引数部分のうち、単に構造体を結びつけるためだけに用意したレジスタ変数操作を省略して、ダイレクトに構造体
　を代入するように、手順を切り詰めた
このように手順を切り詰めたことにより、切り詰めた箇所の命令は、実行タイミングが繰り上がった（より早期になった）
③一方でp/3構造体の引数のうち、変数部分は（これ以上切り詰められないので）そのままとした：しかし引数専用命令に置き換わってはいる
こっちの見方の方が当たっているのかもしれない。。。
クエリとの関係でみても・・・
プログラムが起動される時には、A1-A3の引数レジスタにはすでに値がセットされており、
プログラム側は、そのA1-A3レジスタに対する処理を最優先で実行するように調整するべきである。とも考えられる。
）
```
```
参考:＞＞＞＞＞
  (L0言語クエリ 「?-p(Z,h(Z,W),f(W))」のM0仮想マシンコード)
  put_structure h/2,x3
  set_variable X2
  set_variable X5
  put_structure f/1,x4
  set_value X5
  put_structure p/3,x1
  set_value X2
  set_value X3
  set_value X4

L0プログラム「p(f(X),h(Y,f(a)),Y).」の仮想マシンM0のマシンコード
  get_structure p/3,x1
  unify_variable x2
  unify_variable x3
  unify_variable x4
  get_structure f/1,x2
  unify_variable x5
  get_structure h/2,x3
  unify_value x4
  unify_variable x6
  get_structure f/1,x6
  unify_variable x7
  get_structure a/0,x7

こうやってみると・・・
・put_structure p3 / get_structure p3 の部分が省略されているため、コードが大幅にコンパクトになっている
・p3に対する、HEAPとレジスタのデータのやりとりが無くなるので、大幅に高速化される。
・また、query と code の引数(A1〜A3)渡しが、暗黙のうちに行われているとも言えるので、
　その観点としても際立った高速化がなされているといえる。
　（通常のプログラミング言語ならば、スタックに引数を保存して渡すことになるの対し、WAMでは直接レジスタを引き継がせているので、
　　恐ろしく高速(というか処理時間がゼロ)になっていると言えるだろう）
＞＞＞＞＞
```




　
## <a name="chapter2">2.【L2言語定義: Flat Resolution】 </a>

  L2は、Prologの基本言語仕様のうちバックトラックだけが未実装のものである。
  - L2は、L1をさらに拡張し、手続き処理として body を持てるようにする。
  - body 部分は atom の連言として定義する。
  - 各述語名につき最大１つの節(clause)を定義する。
    `(訳注: L2では、１つの述語に対して複数の clause を定義することはできない。まだバックトラックが実装されていないからである。)`

  #### ・構文(Syntax)
      L2プログラムでは、手続きは、 'a0 :- a1,....,an.' 形式で定義される
      ここで、　n >= 0 かつ a はアトムとする。

      これまでファクトと呼んできたものは、 n = 0 の場合の節(clause)であるとし、
      ファクトの場合は ' :- ' シンボルを省略しているものとする。

      n > 0 の場合、節(clause)をルールと呼ぶ。

      単一の body から構成される goal を チェイン・ルール と呼び、それ以外を ディープ・ルール と呼ぶ。

      L2 クエリは、 ' ?- g1,...gk. ' 形式の goal 列を許容する。
      (ここで k >= 0 である。)

      (Prologと同様に)変数のスコープは、clause やクエリ内に制約される。

  #### ・構文の意味(Semantics)
      クエリ ' ?-g1,...,gk. ' を、手続き定義節の集合からなるプログラムのコンテキストとして実行する。
      ここでいう手続き定義節の集合とは、
      クエリ要素(g1〜gkや導出されたbody)が全て無くなるまで(処理して)成功するか、あるいはどこかで失敗してしまうまで、
      繰り返し最左導出を適用するような、手続き定義節の集合のことである。

### 最左導出(Leftmost resolution)
   - g1をその定義の頭部(head)とユニファイする（定義が存在しなければ failする）
   - ユニファイに成功した場合は、g1をその body 部に置き換えた新たなクエリに変換する。
     スコープ内の変数は、ユニフィケーションによる束縛を受ける。

L2におけるクエリ実行は:
   - successにより終了するか
   - failにより終了するか
   - 永遠に終了しないか

   のいずれかである。

L2クエリの実行が success したことにより得られる「結果」とは、
終了時に得た (クエリ中の)変数との(デリファレンスされた)バインド結果のことである。


### 【L2言語のコンパイル】
L2 節のヘッド部のコンパイルについては、M1のファクト命令で充足している。

基本的には各 goal をL1クエリとしてコンパイルしたものを連結することで、コンパイルすることができる。

**しかしながら** M2は、以下の2つの点に注意する必要がある。
   - goalシーケンスの実行継続に関すること
   - 引数レジスタのコンフリクトに関すること


### 【L2におけるファクト】
L2では、 proceed 命令は(最初の)ファクトが成功した後も、
その後続のgoal命令シーケンスに戻って、実行を継続しなければならない。

### 【継続ポイントレジスタ CP】
レジスタ CP は、M2により 次の命令のアドレスを保存＆リストアするために使われる。
(callから成功して処理が戻ったときに、それを継続する必要がある)

このため、L2のファクトにおいては、M1の制御命令を以下のように変更する
```
    call p/n ≡ CP ← P + instruction_size(P);
                P ← @(p/n);

    proceed ≡ P ← CP;
```
```
訳註: 例えば?-a(X),b(X). の場合 P と CP はどのような値がセットされるだろうか?

まず P と CP が最初にセットされるのは、 call a/1 が呼び出されるときである
そしてそのとき P には @(a/1) がセットされるだろう
では CP には何がセットされるのだろうか？
CP には call a/1 が実行し終わった直後の「次の命令」のアドレスがセットされる
そのアドレスに格納される命令は
put_value X1,A2
ということになるであろう(つまり b(X) を呼び出すための、最初の命令が put_value になるからである）
```
以前と同じように、手続き p/n が定義されていない場合は、実行は失敗する。
このシンプルな調整により、L2ファクトは厳密にL1ファクトとして翻訳される。<br>(訳註:つまり上記以外はなにも変更しない)


### 【ルールとクエリ】
まず、ルール
```
P0(...) :- p1(...),...,pn(...).
```
は、以下のパターンに翻訳される
```
      get arguments of P0 (P0の引数変数(複数)をget)
      put arguments of p1 (P1に対応する引数変数(複数)をput)
      call p1
      :
      put arguments of Pn (・・・同上)
      call pn

(クエリの場合は、head 部のない、ルールの特殊なケースとみなせる)
```
   - ここで 1 以上のbodyに現れる変数は permanent と呼ばれ、
      その変数が最初に現れた手続き呼び出しよりも延命させなければならない。
   - それ以外のスコープ内変数は temporary と呼ばれる。

### 【課題】
同じ変数レジスタが各 body と goal で使用されるため、 permanent 変数は上書されるリスクがある。

        例: p(X,Y) :- q(X,Z),r(Z,Y).

この場合変数 Y、Z のレジスタ値が、 q 実行の後もなおそのまま存在しているかどうかは保証されていない。
`（訳註: 変数Xの場合は、q実行後は使用されることがないので破壊されても問題ない）`

##### NOTE:
ルール中の変数が permanent か temporary かを決定するため、
head アトムは最初の body ゴールの一部とみなす※。
        `（たとえば、上記例の変数Xは、temporary である）`
```
脚注 ※ :
  これは、get命令とunify命令はレジスタをロードしないからである(wam bookより)。
  なお、head アトムに存在する変数でも、２つめ以降の body に存在する変数の場合は、
  レジスタの値は 書き換えられる可能性があるので、permanent としなくてはならないだろう。
  結局 temporary となれる変数の種類は以下に限定されるだろう。
      ① headにのみ出現する変数(headで複数使用されるようなケースを想定)
      ② headに出現し、かつ、body部のうち、最初の body に「のみ」出現する変数
      ③ body部中、単一のbody内でのみ出現する変数(そのbody内で複数使用されるようなケース)
```

###   【解決策】
ある手続きに現れる permanent 変数を、その手続きの呼び出しと関連づけた environment(環境フレーム)に保存する(訳註:この領域を事前に確保する処理が、allocateである(後述))。

M2では、手続きの permanent 変数とレジスタCPを、ランタイム・スタックに保存する。
手続きをアクティベートするフレームを environment(環境フレーム) と呼ぶ。

### 【Environment レジスタ E】
レジスタ E は、直近の スタック上の environment(環境フレーム) のアドレスを保持する

M2のスタックは、以下のようなフレームの リンクドリストとして構成される。
```
      E     [CE (一個前の environment(環境フレーム))]
      E + 1 [CP (継続ポイント)]
      E + 2 [n (permanent 変数の数)]
      E + 3 [Y1 (permanent 変数1)]
        :
      E + n + 2 [Yn (permanent 変数n)]
```
(今後は permanent 変数を Yi、 temporary 変数を Xi と表記することにする)

 environment(環境フレーム) は、手続きエントリ call に合わせて スタックにプッシュされ、
    そのリターンに合わせて ポップされる。
```
      例: p0(...) :- P1(...),...,pn(...).
    　は、以下のM2コードに翻訳される。
        allocate N
        get arguments of P0 (P0の引数変数(複数)をget)
        put arguments of p1 (P1に対応する引数変数(複数)をput)
        call p1
          :
        put arguments of pn (・・・同上)
        call pn
        deallocate
```
- allocate N
スタック上に、N個の permanent 変数のフレームとして environment(環境フレーム) を生成した上でスタックにプッシュする。
- deallocate
スタック先頭の environment(環境フレーム)を廃棄し、
廃棄された　environment(環境フレーム)からリカバリされた実行継続ポイントをセットする


```
[allocate deallocate の疑似コード]

        allocate N ≡ newE ← E + STACK[E+2] + 3; (訳註1)
                      STACK[newE] ← E; (訳註2)
                      STACK[newE + 1] ← CP; (訳註3)
                      STACK[newE + 2] ← N;
                      E ← newE;
                      P ← P + instruction_size(P);　
                      （考察: allocate 命令では、個々のpermanent変数の保存はせずに、領域だけ確保している。）


        deallocate ≡ P ← STACK[E + 1] (訳註4)
                     E ← STACK[E]
```

```
(訳註1: 新たなEの位置 = 現在のEの位置 + 現在のEのpermanent変数の数N + 現在のEが管理上保持するスタックの個数3(E,CP,N)
 (というかその先の１個を指している)、と理解する。なお、新たなEの位置を指定することで、との手前のEについて事実上領域確保している（というか、保護しているというべきか）。 )
(訳註2: 現在のEの位置を保持しているため、先に進んでも、ここを参照すると、1つ前に戻れると理解)
(訳註3: この CP は、このルール全体が完了した後の、次の述語
  　　　（つまり、呼び出し元に処理が戻った後の次の述語)を指している。
    以下のような命令の実行順になっている。
    ?- p(X,a),q(X,b). とした場合
    :
    call p/2　　　　　（ここで CP① をセット)
       --- call された側の処理 ---
       ... allocate 2　　　　（CP① は環境スタックに保存される）
       ... get_variable X3,A1
       　　　:
       ... deallocate　　　　（P に CP① をコピー）
       ---
  ①put_value X1,A1  (CP① のアドレス位置)　・・・　q(X,b) の最初の命令位置
    :
)

(訳註4: STACK[E + 1] は CP であることに留意)
```
```
＜プログラム例＞
---
p/2 : allocate 2           % p
      get_variable X3,A1   %  (X,
      get_variable Y1,A2   %     Y):-
      put_value X3,A1      %          q(X,
      put_variable Y2,A2   %              Z
      call q/2             %               ),
      put_value Y2,A1      %          r(Z,
      put_value Y1,A2      %              Y
      call r/2             %               )
      deallocate           %                .
---
M2 machine code for rule p(X,Y) :- q(X,Z),r(Z,Y).
```
```
(訳註:
 明示的に書かれていないが、Y1,Y2は、レジスタではなく、environment(環境フレーム)上の保存領域と解釈すべきと考える。
 そこで、
 　　get_variable Yn,An や get_value Yn,An では、Anの値を、environment(環境フレーム)上のYnにコピーし、
 　　put_variable Yn,An や put_value Yn,An では、environment(環境フレーム)上のYnの値を、Anにコピーする
 というように解釈すべきと考える。
 とすると、上記４つの命令は、Ynにも対応できるように改修が必要ということになる。
 また、何がYn(parmanent変数)となるか？はコンパイル時に決定する必要があるで、コンパイラに判定ロジックが追加で必要となる。
 逆に言うと、それだけで、実現できる。
)

(
ここまで見てきて、だんだん不思議に思ってきたのが、parmanent Yi は、スタックに記録され、いずれ巻き戻されるので、
その意味からすると、全然 parmanent じゃない気がしてくるし、temporary Xi は逆に HEAP に保存されるので、より
永続的なものに見えてくる。まあ、単なる見え方の問題かもしれないが。
)
```
<疑似コード>
```
put_variable Yn,Ai ≡ addr ← E + n + 1;
                     STACK[addr] ← <REF,addr>;
                     Ai ← STACK[addr];
                     P ← P + instruction_size(P);
```



## <a name="chapter3">3.純粋Prolog (Language L3: Pure Prolog) </a>

  ### ・構文(Syntax)
  - L3 はL2を拡張し、選言的な定義を許容する(注釈:つまり複数定義を可能とし、バックトラックを許す)
  - L2 と同じく、L3プログラムは、手続き定義の集合とする。
  - L3 における「定義」とは、順序づけられた 節の列(sequence)とする（つまり、ファクトやルールの列である）。
しかもこれらの節は、同一の述語名を共有する head アトムのすべてからなる。・・・手続きの名前は、この定義により規定される。
  - L3 クエリは L2と同様である。


 ### ・構文の意味(Semantics)
  - トップダウンの最左導出により処理される。これはSLDレゾリューション解析の一種である。
  - ユニフィケーションの失敗は、もはや 実行全体の abort とはならず、
    バックトラッキングにより他の選択を実行する。
    つまり(ユニフィケーションが)失敗したその時、直前の(別の)候補が選択され、リトライされる。

  M3は M2の設計を変更し、他の選択枝を提示できるように各手続き呼び出しの状態を保存する。

  我々はこれを、選択ポイント（choice point）フレームと呼ぶことにする：

  これは、失敗した計算のすべての影響を元に戻して、次の選択枝を試行するために必要な全ての関連情報を含んでいる。

  M3 では、選択ポイントをスタック内のフレームとして管理する(まさにenvironmentフレームのように)
  両者のスタックを区別するため、environment スタックを ANDスタック、
  選択ポイントスタックを ORスタック、と呼ぶことにする。

### 【バックトラックレジスタ: B】

レジスタ B は、直近の選択ポイントフレームのアドレスを保持する。

  - 失敗した場合、Bで示される選択ポイントフレームを元に、リカバリーされた状態から
    計算が再開される。
  - フレームがこれ以上の選択枝を提示できなくなった場合、ORスタックをポップして
    １つ前のBが存在する場合は、Bによりリセットする。
    さもなければ、計算全体が最終的に失敗する。

   ##### NOTE:
　仮に 1つの節だけが定義されている場合は、選択ポイントを作る必要はない。この場合は、M2と全く同じ取り扱いとなる。


  １以上の選択肢が定義された場合は、
  - 選択ポイントフレームは、最初の選択肢から生成される
  - その上で、それは（試行されるべき次の選択肢がある限り）中間の選択肢により
      更新される（ただし最後の選択肢は除く）
  - 最終的に、最後の選択肢により破棄される。

### 【環境の保護(Environment protection)】

### 【課題】
  (決定論的な)L2では、ルールの終了時点での environment(環境フレーム)
  の再配置は安全であった。

  L3ではもはやそれは正しくない:

  直前の失敗は、environment が再アロケートされたことによるルールの適用中
  に計算状態からの選択により再評価される
```
  <プログラム例>
    Program:
      a:- b(X),c(X).
      b(X):-e(X).
      c(1).
      e(X):-f(X).
      e(X):-g(X).
      f(2).
      g(1).

    Query:
      ?- a.
```
   - a のenvironmentをアロケート
   - b を call
   - b のenvironmentをアロケート
   - e を call:
      - e の選択ポイントを作成してプッシュ
      - e の environment をアロケート
```
      ＜スタックの格納図＞
           |        :         |
           |Environment for a |
           |Environment for b |       |        :         |
      E -> |Environment for e |  B -> |Choice point for e|
```

   - f を call;
   - 成功 succeed (X=2);
   - e の environment を deallocate
   - b の environment を deallocate
```
      ＜図式＞
      |        :         |       |        :         |
 E -> |Environment for a |  B -> |Choice point for e|
```
aのbody部の実行を継続:
   - c を call;
   - 失敗(X=2≠1);

Bが示す選択ポイントは eの選択肢を示しているが、
この時点で bの environment は失われている。(ここがProblemか)

M3では、既存の選択ポイントよりも時間的に先行する environment フレームについて回復不能な
deallocation を防止する必要がある。

### 【アイデア】
全ての選択ポイントは、
それが生成されるよりも「前に」存在していた全ての environment(環境フレーム)
の deallocation から「保護」しなければならない。

### 【解決策】
M3は、environment(環境フレーム)と選択ポイントを同一のスタックで使用するようにする:
これからは、選択ポイントは、全てのより古いenvironment(環境フレーム)をキャップ(保護)する。

  - 選択ポイントがアクティブである限り、
    （明示的にdeallocateされたものであっても）より古い environment(環境フレーム)の上書きを排除して、
    強制的に environment(環境フレーム) のアロケーションを維持する。
  - この選択ポイントから別の選択肢に戻ると、deallocateされたが 保護されている environment(環境フレーム)の安全な復活(resurrection)が自動的に行われる。
  - この保護は必要とされる限り持続するが、この選択ポイントがなくなりしだい(disappers)、明示的にdeallocateされたenvironment(環境フレーム)はすべて安全に上書きされることになる。

先の例に戻る・・・(Back to our example):
  - a の environment をアロケート
  - b を call
  - b の environment をアロケート
  - e を call
      - e の選択ポイントを作成してプッシュ
      - e の environment をアロケート
```
        ＜図式＞
         |               :            |
         |       Environment for a    |
         |       Environment for b    |
    B -> |       ChoicePoint for e    |
    E -> |       Environment for e    |
```


  - f を call
  - 成功(X=2);
  - e の environment をデアロケート
  - b の environment をデアロケート
```
      ＜図式＞
       |               :             |
  E -> |       Environment for a     |
       |Deallocated environment for b|
  B -> |       Choice point for e    |
```

aのボディ部の実行を継続(Counting with execution of a's body:)
   - c を call
   - 失敗(X=2≠1);

この時点で、M3は e の選択ポイント(Bで示されていた)を使って、
安全に状態を回復することができる。
この場合、復元する保存された environment は、
この選択ポイントの作成時において現在のもの（つまりb）である。
   - バックトラックする;
   - e の選択ポイントを破棄;
(環境の)保護はこの時点で(安全に)終了する。

proceed のための、最後の選択肢の実行(Execution of the last alternative for e procceds with):
```
    ＜図式＞
B -> |                             |
     |               :             |
     |       Environment for a     |
     |       Environment for b     |
E -> |       Environment for e     |
```

### 【バインド処理のアンドゥ(Undoing bindings)】
バインド処理の影響は、選択肢の再検討の時点で無効化しなければならない。

M3は、バックトラック時に　unbound するためにリセットが必要な全ての変数をトレイル と呼ばれるデータエリアに記録する。

###  【トレイルレジスタ TR】
レジスタ TR は、次の使用可能なTRAILのアドレスを保持する

##### NOTE:
条件付きバインドだけが、トレイルされる必要がある。

  条件付きバインドとは、影響を受けた変数のうち、現在の選択ポイント
  を生成するよりも前に存在していたものを指す。

### 【ヒープ・バックトラック・レジスタ HB】
レジスタ HBは、最新の選択ポイントが生成された時点の レジスタ H の値を保持する。

  - HEAP[a] は、a < HB の場合 conditional である。
  - STACK[a] は、a < B の場合 conditional である。


### 【選択ポイントにはどんなデータが含まれる？】
   - 引数レジスタ A1,...,An (n は、定義の代替選択を提供する手続きのアリテイである)
   - (CE) 現在の environment （レジスタEの値）。
     保護された environment のリカバリのため利用する。
   - (CP) 継続ポインタ（レジスタCPの値）。
     現在の選択(choice)はこの値で上書きされる。
   - (B) 最新の選択ポイント（レジスタBの値）。
     現在の適用中の選択ポイントによって提供されたすべての選択肢が失敗した場合にバックトラックする。
   - (L) 次の節
   （現在選択されているものが失敗した場合に(バックトラックして)この定義を試す）
    より多くの選択肢が存在する場合、このスロットはこの選択ポイントまで、バックトラックするたびに更新される。
   - (TR) 現在のTRAILポインタ（レジスタTRの値）。
    これはバックトラック時にTRAILを巻き戻す場所の境界として必要。
   - (H) 現在のHEAP領域の先頭（レジスタHの値）
   　失敗した試行中に構築された すべての構造体および変数の HEAP領域を回復（ガベージコレクション）するために必要。
```
    Choice point frame:
     <図表>
     B     | n (number of arguments)       |
     B+1   | A1 (argument register 1)      |
                       :
     B+n   | An (argument register n)      |
     B+n+1 | CE (contunuation environment) |
     B+n+2 | CP (continuation pointer)     |
     B+n+3 | B  (previous choice point)    |
     B+n+4 | L  (next clause)              |(訳註: 原文は BP だったが、以降の説明を考慮して L とした)
     B+n+5 | TR (trail pointer)            |
     B+n+6 | H  (heap pointer)             |
```
##### NOTE:
M3では、M2の allocateの定義を変更する:
```
      <allocate(変更後) の疑似コード>
      allocate N ≡ if E > B
                      then
                        newE ← E + STACK[E+2] + 3
                      else
                        newE ← B + STACK[B] + 7;
                    STACK[newE  ] ← E;
                    STACK[newE+1] ← CP;
                    STACK[newE+2] ← N;
                    E ← newE;
                    P ← P + instruction_size(P);

      (訳註: deallocate のコードには変化がなく、allocate で変更を吸収している格好になっている)
```
### 【選択命令(Choice instructions)】
与えられた 複数節の定義では、M3は、３つの命令を使用して取り扱う:

1. 最初の節
2. 中間の節
3. 最後の節

  それぞれ・・・:
1. try_me_else L
      新しい選択ポイントフレームをスタックにアロケートし、
      それを次の節のフィールドとして L に設定する。
      そして、現在のコンテキストにおける他のフィールドは
      これをポイントするように、Bにセットする。
2. retry_me_else L
      現在の選択ポイントから全ての情報をリセットし、
      次の節のフィールドである L で更新する。
3. trust_me
      現在の選択ポイントから全ての情報をリセットし、
      その上で B をリセットすることにより、これを破棄(discard)する。

### 【バックトラック(Backtracking)】

M3では、すべてのM2命令が失敗する可能性がある
    (つまり、いくつかのユニフィケーション命令と、全ての手続き命令が)
    が、このようなすべての選択肢が失敗した場合に、
    以下のようなオペレーションを実行する。
```
    <バックトラックの疑似コード>
      backtrack ≡ P ← STACK[B + STACK[B] + 4];
      (訳註: STACK[B]には引数の数 n がセットされているので、実質的にはSTACK[B+n+4]の意である）
      (訳註: つまり、L をセットする)
```
(backtrackでは)通常のシーケンスに従って進むのとは対照的に、レジスタ P を無条件にセットする
(その上で)スタックにこれ以上の選択ポイントが存在しなくなった場合には、
最終的に失敗してアボートする。
```
    (考察:
     　・・・wambookを読むと、backtrackは、trymeなどの制御命令に関連して呼び出されるのではなく、
     (trymeは、単純に選択ポイントの設定をしているだけのようである)　unifyなどが失敗した場合などに、
     突発的に呼び出されると考えるべきもののようである。
      ・・・そうなると、get_structure や、put_valueなども、改修が必要ということになる
      　　（これまでは fail で abortしていたものが、backtrackの対象となるということか。。。）
      それで、backtrackがやっていることは、単にPをセットしなおして、次のジャンプ先に飛ばすことだけのようである。
      たとえば、
        try_me_else L では、Bをセットしなおして、選択ポイントを設定し、次のジャンプ先を L にしている。
        backtrack では、次のジャンプ先である L にジャンプする。
      という動きになっている。
    )
```
```
   <疑似コード>
   try_me_else L ≡ if E > B
                     then newB ← E + STACK[E + 2] + 3
                     else newB ← B + STACK[B] + 7;
                   STACK[newB] ←  num_of_args;
                   n ← STACK[newB]
                   for i ← 1 to n do STACK[newB + i] ← Ai;
                   STACK[newB + n + 1] ← E;
                   STACK[newB + n + 2] ← CP;
                   STACK[newB + n + 3] ← B;
                   STACK[newB + n + 4] ← L;
                   STACK[newB + n + 5] ← TR;
                   STACK[newB + n + 6] ← H;
                   B ← newB;
                   HB ← H;
                   P ← P + instruction_size(P);

   retry_me_else L ≡ n ← STACK[B];
                    for i ← 1 to n do Ai ← STACK[B + i];
                    E  ← STACK[B + n + 1];
                    CP ← STACK[B + n + 2];
                    STACK[B + n + 4] ← L;
                    unwind_trail(STACK[B + n + 5],TR);
                    TR ← STACK[B + n + 5];
                    H  ← STACK[B + n + 6];
                    HB ← H;
                    P  ← P + instruction_size(P);

   trust_me        ≡ n ← STACK[B];
                    for i ← 1 to n do Ai ← STACK[B + i];
                    E  ← STACK[B + n + 1];
                    CP ← STACK[B + n + 2];
                    unwind_trail(STACK[B + n + 5],TR);
                    TR ← STACK[B + n + 5];
                    H  ← STACK[B + n + 6];
                    B  ← STACK[B + n + 3];
                    HB ← H;
                    P  ← P + instruction_size(P);

   procedure unwind_trail(a1, a2 : address);
     for i ← a1 to a2 -1 do
       STORE[TRAIL[i]] ← <REF,TRAIL[i]>;
   end unwind_trail;

   procedure trail( a: address);
     if (a < HB) or ((H < a ) and (a < B))
       then
         begin
           TRAIL[TR] ← a;
           TR ← TR + 1;
         end
   end trail;

   --- bind関数 (trail対応後）
   procedure bind(a1, a2: address);
   <t1,_> ← STORE[a1]; <t1,_> ← STORE[a2];
   if (t1 = REF) and ((t2 ≠ REF) or (a2 < a1))
     then
       begin
          STORE[a1] ← STORE[a2]; trail(a1)
       end
     else
       begin
          STORE[a2] ← STORE[a1]; trail(a2)
       end
   end bind;
```

### 【L3コンパイルについてのまとめ(Recapitulation of L3 compilation)】
- M3コードでは、単一節の定義に対して生成されたものは、M2のL2プログラムに対して生成されたものと同一である。

- 2つの節で定義された　手続き p/n の場合は、以下のようなパターンになる:
```
    p/n : try_me_else L （最初の節のためのコード）
    L   : trust_me       (2つめの節のためのコード)
```
- それ以上の数の節定義についは以下:
```
    P/n : try_me_else L1
    L1  : try_me_else L2
    Lk-1: try_me_else Lk
    Lk  : trust_me
```
 各節は、M2の単一節L2と同じように翻訳される。
```
  Example,
      p(X,a).
      p(b,X).
      p(X,Y) :- p(X,a), p(b,Y).
```

```
  ＜サンプルコード＞
  ---
  p/2: try_me_else L1        % p
       get_variable X3,A1   %  (X,
       get_structure a/0,A2 %     a)
       proceed              %       .
  L1 : retry_me_else L2      % p
       get_structure b/0,A1 %  (b,
       get_variable X3,A2   %     X)
       proceed              %       .
  L2 : trust_me             %
       allocate 1           % p
       get_variable X3,A1   %  (X,
       get_variable Y1,A2   %     Y):-
       put_value X3,A1      %          p(X,
       put_structure a/0,A2 %              a
       call p/2             %               ),
       put_structure b/0,A1 %          p(b,
       put_value Y1,A2      %              Y
       call p/2             %               )
       deallocete           %                .
---
M3 code for a multiple-clause procedure
```
<br><br><br>
---- (L3言語おわり) ----





## <a name="chapter4">4. 最適化 (Optimizing the Design) </a>


##### WAM原則1
ヒープスペースは、できる限り控えめに使用されるべきであり、ヒープ上に構築されたものは、相対的に永続的なものであるべきである。

##### WAM原則2
レジスタは、不要なデータ移動を極力避けてアロケートされなければならないし、そしてコードサイズもまた極力最小化されるよう調整されるべきである。

##### WAM原則3
発生頻度の高い、特定の条件においては（仮に一般的なケースの命令処理において、十分適切に制御されていたとしても）
その特異性によりもたらされる恩恵により、スペースや時間を節約することができるのであれば、特別にその便宜を図るべきである。

### [ヒープの最適化 Heap representation]
ヒープにおける、より望ましいデータ配置は以下となろう
```
(p(Z,h(Z,W),f(W))
   0|h/2  |
   1|REF|1|
   2|REF|2|
   3|f/1  |
   4|REF|2|
   5|p/3  |
   6|REF|1|
   7|STR|0|
   8|STR|3|
```
ストアやレジスタからの参照は全て <STR,5> のセル形式になっている。

しかし、各ファンクターセルに対して、その直前に定型的な STR セルを割り当てるということは、実のところ必要性はないのである。

```
本文冒頭の Heap レイアウトを参考までに再掲載する・・・
(p(Z,h(Z,W),f(W))
   0|STR|1|
   1| h/2 |
   2|REF|2|
   3|REF|3|
   4|STR|5|
   5| f/1 |
   6|REF|3|
   7|STR|8|
   8| p/3 |
   9|REF|2|
  10|STR|1|
  11|STR|5|
```

このために必要なことは、put_structure 命令を次のように変更することだけである:
```
put_structure f/n,Xi ≡ HEAP[H] ← f/n;
                       Xi ← <STR,H>;
                       H ← H + 1;
```

```
比較のために、元の定義を併記する。
put_structure f/n,Xi ≡ HEAP[H] ← <STR,H+1>;
                       HEAP[H+1] ← f/n
                       Xi ← HEAP[H];
                       H ← H + 2;
(Xiには、最適化後は <STR,H> がセットされているが、双方とも f/nの位置をセットしていることに変わりはない)
```
　

### 【定数・リスト・無名変数(Constants,lists, and anonymous variables)】

#### [定数]
    unify_variable Xi
    get_structure c/0,Xi

これを１つの特化した命令に単純化する
```
    unify_constant c
```
そして
```
put_structure c/0,Xi
set_variable Xi
```
もまた、同じように単純化を行う
```
    set_constant c
```

同じように put と get 命令もまた、定数に特化することで単純化できる

我々は、定数を識別するため、この種のデータセルに新たに「CON」タグを付与することにする。

e.g., 構造体 f(b,g(a))を例にすると、ヒープ表現は以下となる(アドレス10から始まる)
```
    8|    g/1    |
    9| CON |  a  |
   10|    f/2    |
   11| CON |  b  |
   12| STR |  8  |
```

```
訳註：上記ヒープ表現を従来の方法で表現すると以下のようになる
    8|    g/1    |
    9|    a/0    |
   10|    f/2    |
   11|    b/0    |
   12| STR |  8  |
一見さほど変化していないように見えるが、(0であるにも関わらず)引数個数のエリアが
余計に必要であったのでその分は省スペース化される
```


この最適化は、定数に対するレジスタからのロードや、変数とのバインドをする際に、Heap のスペースを軽減することになる:

これにより（定数は）、文字通りの値として取り扱われる。
```
Constant-handling instructions:
・put_constant c,Xi
・get_constant c,Xi
・set_constant c
・unify_constant c
```

＜各命令の擬似コード＞
```
put_constant c,Xi ≡ Xi ← <CON,c>;

get_constant ≡
    addr ← deref(Xi);
    case STORE[addr] of
      <REF,_> : STORE[addr] ← <CON,c>;
                trail(addr);
      <CON,c'>: fail ← (c ≠ c');
      other   : fail ← true;
    endcase;

set_constant c ≡ HEAP[H] ← <CON,c>;
                 H ← H + 1;

unify_constant c ≡
    case mode of
      READ : addr ← deref(S);
             case STORE[addr] of
               <REF,_> : STORE[addr] ← <CON,c>;
                         trail(addr);
               <CON,c'>: fail ← (c ≠ c');
               other   : fail ← true;
             endcase;
      WRITE : HEAP[H] ← <CON,c>;
              H ← H + 1;
    endcase;

```
　

#### [リスト]
空でないリストならば、このリストのファンクター表現をヒープ上で明示的に格納する必要はないだろう。

（新たに）「LIS」タグを定義し、（この「LIS」タグを付与した）ヒープ上のセルにリスト・ペアの先頭アドレスが含まれていることを示すことにする。


＜リスト制御命令の擬似コード＞
```
put_list Xi ≡ Xi ← <LIS,H>;

get_list Xi ≡ addr ← deref(Xi);
              case STORE[addr] of
                <REF,_> : HEAP[H] ← <LIS,H+1>;
                          bind(addr,H);
                          H ← H + 1;
                          mode ← WRITE;
                <LIS,a> : S ← a;
                          mode ← READ;
                other   : fail ← true;
             endcase;
```

```
＜クエリ例＞: ?-p(Z,[Z,W],f(W)).

      put_list X5           % ?-X5 = [
      set_variable X6       %         W|
      set_constant []       %           []],
      put_variable X4,A1    %   p(Z,
      put_list A2           %       [
      set_value X4          %        Z|
      set_value X5          %          X5],
      put_structure f/1,A3  %              f
      set_value X6          %               (W)
      call p/3              %                  ).
```

```
＜プログラム例＞: p(f(X),[Y,f(a)],Y).

p/3 : get_structure f/1,A1  %   p(f
      unify_variable X4     %      (X,
      get_list A2           %         [
      unify_variable X5     %          Y|
      unify_variable X6     %            X6],
      get_value X5,A3       %                Y),
      get_list X6           %   X6 = [
      unify_variable X7     %         X7|
      unify_constant []     %            []],
      get_structure f/1,X7  %   X7 = f
      unify_constant a      %         (a)
      proceed               %            .

```

　
#### [無名変数]
引数変数でない位置の変数のうち、１度しか出現しない変数の場合は、レジスタ使用を省略できる。

f(_, _, _) のように、いくつも連続して発生する無名変数の場合、これらを一挙に処理することができる。

無名変数に関する各種命令：
- set_void n

    ヒープに、未バインドのREFセルをn個プッシュする
- unify_void n

    WRITEモードでは、set_void n; のようにふるまう

    READモードでは、次の n 個のヒープセルをスキップし、Sの位置から開始する

<擬似コード>
```
set_void ≡ for i ← H to H+n-1 do
             HEAP[i] ← <REF,i>;
           H ← H + n;

unify_void n ≡ case mode of
                 READ  : S ← S + n;
                 WRITE : for i ← H to H+n-1 do
                           HEAP[i] ← <REF,i>;
                         H ← H + n;
               endcase
```
NOTE: 無名の先頭引数は、単純に無視される

    get_variable Xi,Ai

の変数Xiは明らかに空だからである

```
<ファクトp(_,g(X),f(_,Y,_)).のプログラム例>

p/3 : get_structure g/1,A2  %  p(_,g
      unify_void 1          %       (X),
      get_structure f/3,A3  %           f
      unify_void 3          %            (_,Y,_)
      proceed               %                   ).
```

　
#### [レジスタ割当て]
巧みなレジスタ割り当てにより、peep-hole 最適化を可能とする

e.g., ファクト conc([],L,L,).の場合のコード例:
```
conc/3 : get_constant [],A1  % conc([],
         get_variable X4,A2  %         L,
         get_value X4,A3     %           L)
         proceed             %             .
```
このコードの中で、変数Lのために X4を使用することは馬鹿げている：A2を使おう！

⇨ get_variable A2,A2 は無意味なオペレーションなので、省略できる：
```
conc/3 : get_constant [],A1  % conc([],
         get_value A2,A3     %         L,L)
         proceed             %             .
```
一般的に、レジスタ同士のアロケーションは、意味のないオペレーションである。

    get_variable Xi,Ai  put_value Xi,Ai

これらは省略できる

([2]を参照のこと）
```
プログラム例: p(X,Y) :- q(X,Z),r(Z,Y).

p/2 : allocate 2         % p
      get_variable X3,A1 %  (X,
      get_variable Y1,A2 %     Y):-
      put_value X3,A1    %          q(X,
      put_variable Y2,A2 %              Z
      call q/2           %               ),
      put_value Y2,A1    %          r(Z,
      put_value Y1,A2    %              Y
      call r/2           %               )
      deallocate         %                .
```

```
レジスタ割付を改善したプログラム例: p(X,Y) :- q(X,Z),r(Z,Y).

p/2 : allocate 2         % p
      get_variable Y1,A2 %  (X,Y):-
      get_variable Y2,A2 %          q(X,Z
      call q/2           %               ),
      put_value Y2,A1    %          r(Z,
      put_value Y1,A2    %              Y
      call r/2           %               )
      deallocate         %                .
```

　
#### [末尾最適化]
末尾最適化(LCO)は、（スタックフレームのリカバリプロセスとしての）テイル・リカージョン最適化の一般化である。

アイデア：permanent 変数は、ボディ内の最後の呼び出しの手前で、（かつ）すべてのput命令が実行された後では、もはや必要とされない。

⇨ ルール本体の最後の呼び出しの「前」に、現在の環境を破棄しよう

単純に： ルールの命令シーケンスの最後の call, deallocate の順番を入れ替えるだけだ
（i.e.,つまり deallocate, call）。

注意：deallocate はもはや最後の命令とはならない。このため、PではなくCPをリセットしなければならない：
```
deallocate ≡ CP ← STACK[E+1];
             E ← STACK[E];
             P ← P + instruction_size(P)
```

注意：しかし call が最後の命令となる場合は、CPではなく、Pをリセットしなければならない：

でも、最後でない場合の call の動作は正しいので、我々は call 自体を改変することはできない

call が最後の命令となる場合のために、execute p/n を使用することとしよう:
```
<擬似コード>
execute p/n ≡ P ← @(p/n);
```

```
LCO対策済みのコード例: P(X,Y) :- q(X,Z),r(Z,Y).

p/2 : allocate 2         %  p
      get_variable Y1,A2 %   (X,Y) :-
      put_variable Y2,A2 %            q(X,Z
      call q/2           %                 ),
      put_value Y2,A1    %            r(Z,
      put_value Y1,A2    %                Y
      deallocate         %                 )
      execute r/2        %                  .
```

　
#### [チェインルール]

以下のようなチェインルールの形式に対してLCOを適用してみる
```
p(...) :- q(...).
```
以下が与えられる:
```
p : allocate N
    get arguments of p
    put arguments of q
    deallocate
    execute q
```
しかし、チェインルール内の全ての変数は、必然的に temporary 変数である

⇨ LCOを適用すると allocate/deallocate はチェインルールの中では不要となる ー これらを削除しよう！

i.e., 以下の形式のチェインルールを翻訳しなおす
```
p(...) :- q(...).
```
このように：
```
p : get arguments of p
    put arguments of q
    execute q
```
チェインルールでは、スタックフレームは全く不要である！

　
#### [環境フレームの刈り込み(Environment trimming EL)]
LCOを徹底する：permanent 変数が不要になり次第直ちに破棄する

⇨ 現在の環境フレームを漸次削減し、最終的には、LCOによって完全に消滅するようにする

ルールのPV(permanent変数)をランク付けして、PVの最終ゴールが遅いほど、現在の環境フレームのオフセットが小さくなるようにする

e.g., 以下において
```
p(X,Y,Z) :- q(U,V,W),r(Y,Z,U),s(U,W),t(X,V).
```
全ての変数は permanentである：
```
    | Variable | Last goal | Offset |
    |    X     |     t     |   Y1   |
    |    Y     |     r     |   Y5   |
    |    Z     |     r     |   Y6   |
    |    U     |     s     |   Y3   |
    |    V     |     t     |   Y2   |
    |    W     |     s     |   Y4   |
```
これからは、call は call後もなお必要とされる PVの数をカウントする第2引数を取ることとする


注意：常に正しい stack オフセットを反映するように allocate の動作を修正すること

事実：環境のCPフィールドであるSTACK[E + 1]には常に、call P,N（Nは希望のオフセット）の直後の命令アドレスが含まれる。

⇨ allocate はもはや引数を必要としなくなり、環境はオフセットフィールドを必要としなくなった

```
E  |  CE (continuation environment) |
E+1|  CP (continuation point)       |
E+2|  Y1 (permanent variable 1)     |
   |              :                 |
```
　

CODE[STACK[E+1] 1] として適切に刈り込まれたオフセットを取得するように、allocateを変更する：
```
allocate ≡
     if E > V
       then newE ← E + CODE[STACK[E+1] - 1] + 2
       else newE ← B + STACK[B] + 7;
     STACK[newE] ← E;
     STACK[newE+1] ← CP;
     E ← newE;
     P ← P + instruction_size(P);

( try_me_elseに類似する。。。）
```

```
環境フレームを最適化したコード：

p/3 : allocate           % p
      get_variable Y1,A1 %  (X,
      get_variable Y5,A2 %     Y,
      get_variable Y6,A3 %       Z) :-
      put_variable Y3,A1 %             q(U,
      put_variable Y2,A2 %                 V,
      put_variable Y4,A3 %                   W
      call q/3,6         %                    ),
      put_value Y5,A1    %             r(Y,
      put_value Y6,A2    %                 Z,
      put_value Y3,A3    %                   U
      call r/3,4         %                    ),
      put_value Y3,A1    %              s(U,
      put_value Y4,A2    %                  W
      call s/2,2         %                   ),
      put_value Y1,A1    %              t(X,
      put_value Y2,A2    %                  V
      deallocate         %                   )
      execute t/2        %                    .
```
　

#### [スタック変数]
ゴール引数としてルール本体に最初に現れるpermanent変数である Ynは、put_variable Yn,Ai 命令で初期化される。

これにより、Ynと引数レジスタAiの両方がヒープ上の新しいセルを指すように体系的に設定される。

⇨ put_variable 命令を permanent変数 の場合とtemporary変数 の場合とで異なる動作をするように変更し、
temporary変数 の場合はヒープセルを割り当てるところ、permanent変数 の場合はこれを行わないようにする。

i.e.,
```
put_variable Yn,Ai ≡
      addr ← E+n+1;
      STACK[addr] ← <REF,addr>
      Ai ← STACK[addr];
```

残念なことに、この一見無害に見える変更には、ETとLCOを妨げるという、かなり危険な影響がある。

　
##### トラブル
permanent変数が（LCOとETによって）未拘束のまま廃棄される可能性がある。

⇨ 危険：参照先が宙に浮いた状態（未保証となる）危険性がある！

e.g.,
- バインドされていない2つの変数の間で、バインドが任意のポインタ方向を選択するのは正しくない。
- 今や、いくつかの命令は、特定の状況で盲目的に使用された場合、不適切となる可能性がある：
put_value と set_value 命令など （このことは、WRITEモード時の unify_value でも起こり得る）

　
##### 対策
- バインディング規約を順守する
- put_value、set_value、unify_valueで何が問題なのかをオンザフライで分析し ・・・ 本当に必要なときだけ回避する

　
#### [変数バインディングとメモリレイアウト]

結局のところ、ほとんどの適切な変数バインディングは、単純な時系列参照ルールに従えば確実に行える：

　
##### WAMバインディングルール1
　　常に、アドレスの大きい変数がアドレスの小さい変数を参照するようにする。

言い換えれば、古い（最近作られていない）変数は若い（より最近作られた）変数を参照できない。

　
##### WAMバインディングルール1の利点
変数-変数間のバインディングには、以下の３つの可能性がある

（１）ヒープ - ヒープ

（２）スタック - スタック

（３）ヒープ - スタック

　
- ケース（１）：無条件のバインディングは、条件付きのバインディングよりも優遇する：
⇨ トレイルの必要がない
⇨ バックトラック時に素早くヒープ領域を回復できる
- ケース（２）：同じく適用されるが、環境内の環境フレーム刈込(ET)のpermanent変数(PV)ランキングでも一貫して機能する。
残念なことに、参照が宙に浮く危険性をすべて防ぐには不十分である
- ケース（３）：スタックへの参照は安全ではない；このため以下の追加ルールが必要である
##### WAMバインディングルール2
　ヒープ変数は決してスタックへの参照に設定してはならない；

また、特定のメモリレイアウトの規則に従うことで、WAMのバインディングルール1との整合性を保つことができる：
##### WAMバインディングルール3
　スタックは、同じグローバルアドレス空間内で、ヒープよりも高いアドレスに割り当てられなければならない

　
#### [安全ではない変数]

　
##### 未だに残る課題
「WAMバインディングルール2」は未だに put_value、set_value、unify_value で問題を引き起こす可能性がある。

put_variable によって初期化されたPV（すなわち、ボディゴールの引数として最初に出現したPV）は、unsafeと呼ばれる。

e.g.,以下について
```
p(X) :- q(Y,X), r(Y,X).
```
XとYはどちらも permanent変数(PV)だが、Yのみ、unsafeである

述語 p が未束縛の引数とともに呼び出されたと仮定しよう

e.g.,
```
put_variable Xi,A1
execute p/1
```

安全でないコード p(X) :- q(Y,X),r(Y,X).
```
<0> p/1 : deallocate         % p
<1>       get_variable Y1,A1 %  (X) :-
<2>       put_variable Y2,A1 %         q(Y,
<3>       put_value Y1,A2    %             X
<4>       call q/2,2         %              ),
<5>       put_value Y2,A1    %         r(Y,
<6>       put_value Y1,A2    %             X
<7>       deallocate         %              )
<8>       execute r/2        %               .
```
0 行目の前に、A1はヒープの一番上にある未束縛のREFセルのヒープアドレス（仮に36としておこう）を指している：


```
(A1) | REF | 36 |              HEAP
                           |          |
                        36 | REF | 36 |
                           |          |
```
次に、allocateはスタック上に環境を作る（例えば、Y1はスタックのアドレス77に、Y2はアドレス78にある）：

```
(A1) | REF | 36 |              HEAP
                           |          |
                        36 | REF | 36 |
                           |          |

                               STACK
                           |          |
                   (Y1) 77 |          |
                   (Y2) 78 |          |
                           |          |
```
1行目の命令で、STAK[77]に <REF,36> をセットし、
2行目の命令で、A1(とSTACK[78]) に <REF,78> をセットする

```
(A1) | REF | 78 |              HEAP
                           |          |
                        36 | REF | 36 |
                           |          |

                               STACK
                           |          |
                   (Y1) 77 | REF | 36 |
                   (Y2) 78 | REF | 78 |
                           |          |
```
3行目の命令で A2に STACK[77] の値をセットするが
これは <REF,36> である
```
(A1) | REF | 78 |              HEAP
                           |          |
                        36 | REF | 36 |
                           |          |

(A2) | REF | 36 |              STACK
                           |          |
                   (Y1) 77 | REF | 36 |
                   (Y2) 78 | REF | 78 |
                           |          |
```
ここで、4行目のqの呼び出しがこれらの設定にまったく影響を与えないと仮定する（例えばファクト q(_ ,_) が定義されているとする）

つぎに、(誤った)5行目では、A1に <REF,78> をセットし、6行目では、A2に <REF,36> をセットする：
```
(A1) | REF | 78 |              HEAP
                           |          |
                        36 | REF | 36 |
                           |          |

(A2) | REF | 36 |              STACK
                           |          |
                   (Y1) 77 | REF | 36 |
                   (Y2) 78 | REF | 78 |
                           |          |
```

その次に、deallocate によって STACK[77] と STACK[78] を捨てる
```
(A1) | REF | 78 |              HEAP
                           |          |
                        36 | REF | 36 |
                           |          |

(A2) | REF | 36 |              STACK
                           |          |
                   (Y1) 77 |    ???   |
                   (Y2) 78 |    ???   |
                           |          |
```
なんと！プログラム r から参照する A1 のアドレスは既にゴミ箱に入っている

　
#### [安全ではない変数の救済]

最後のゴールで安全でない変数Ynが発生する状況としては、2つのケースが考えられる：
- Ynが最後のゴールの引数としてのみ現れる
- Ynが（引数であるか否かにかかわらず）構造体の中に入れ子になったゴールの中に現れる


2つ目のケースについては、（後述する）より一般的な安全性の欠如が原因と考えられる

安全でないYnの出現がすべて、Ynが現れる最後のゴールの引数である場合、それらはすべてYn Aiの値に置かれる

そして、その最後のゴール中 put_value Yn,Ai 命令のうち最初のものを、put_unsafe_value Yn,Ai 命令に置き換える

put_unsafe_value Yn,Ai は put_value Yn,Ai を次のように修正する：
- Ynが現在の環境フレームで未束縛の変数に接続しない場合は、put_value Yn,Aiを実行する
- そうでなければ、スタック変数をヒープ上の新しい未束縛のREFセルにバインドし、Aiをそれにセットする
```
  put_unsafe_value Yn,Ai ≡
      addr ← deref(E+n+1);
      if addr < E
        then Ai ← STORE[addr]
        else
          begin
            HEAP[H] ← <REF,H>;
            bind(addr,H);
            Ai ← HEAP[H];
            H ← H + 1
          end;
```
例に戻る：

行5が put_unsafe_value Y2,A1 だとすると、HEAP[37]が作成され <REF,37> をセットする

STACK[78] と A1 に <REF,37> をセットし、そして A2 に <REF,36>（STACK[77]の値）をセットする：
```
(A1) | REF | 37 |              HEAP
                           |          |
                        36 | REF | 36 |
                        37 | REF | 37 |
                           |          |

(A2) | REF | 36 |              STACK
                           |          |
                   (Y1) 77 |    36    |
                   (Y2) 78 |    37    |
                           |          |
```
STACK[77]とSTACK[78]を破棄しても、こんどは rを実行すればA1とA2から正しい値が得られるので、安全性を確保できている
　
#### [ネストしたスタック参照]
安全でない permanent変数(PV)が構造体の最後のゴールに入れ子になっている（つまり、set_valueやunify_valueとして）場合、
それは temporary変数(TV)にも影響する可能性のある、より一般的な問題を反映している

例えば
```
Rule: a(X) :- b(f(X)).

          a/1 : get_variable X2,A1
                put_structure f/1,A1
                set_vale X2
                execute b/1

Query: ?-a(X),...

                allocate
                put_variable Y1,A1
                call a/1,1
                         :
```
a1を呼び出す前に、Y1を含むスタックフレームがアロケートされ、put_variable Y1,A1 によってunboundに初期化される：
```
(A1) | REF | 82 |





                               STACK
                           |          |
                   (Y1) 82 | REF | 82 |
                           |          |
```
そして、X2に対してそのスタックのスロット（A1の値）を参照するようセットし、
ファンクタ f/1 をヒープ上にプッシュし、set_value X2 命令により X2 の値をヒープ上にプッシュする：
```
(A1) | REF | 57 |              HEAP
                           |          |
                        57 |   f/1    |
                        58 | REF | 82 |
                           |          |

(X2) | REF | 82 |              STACK
                           |          |
                   (Y1) 82 | REF | 82 |
                           |          |
```
ヒープからスタックに参照している！

この行為は「WAMバインディングルール2」に違反しており、Y1が最終的に廃棄される際に災いの種子となる


　
#### [ネストしたスタック参照の救済]
##### 質問：
set_value（各unify_value）が、不要なヒープからスタックへの参照を生成しないであろうと、確実に保証できるのはどのタイミングですか？
##### 答え：
その引数が、指定された節でヒープ上にあるように明示的に初期化されていない場合はいつでも

すなわち、set_value Vn (各unify_value Vn)は、変数Vnがその節内で set_variable または unify_variable で初期されていない場合、あるいは Vn が temporary変数なのに put_variable で初期化されていない場合は、常に安全ではない

##### 救済：
最初の set_value命令(各 unify_value)
を、set_local_value(各 unify_local_value)に置き換える

```
set_local_value Vn ≡
      addr ← deref(Vn);
      if addr < H
        then HEAP[H] ← HEAP[addr]
        else
          begin
            HEAP[H] ← <REF,H>;
            bind(addr,H)
          end;
        H ← H + 1;
```
例に戻る：

もし set_local_value X2 により set_value X2 を置き換えることができれば、X2の値がスタック・アドレスであることを検知し、ヒープ上の新しい未束縛セルにバインドすることができる
```
(A1) | STR | 57 |              HEAP
                           |          |
                        57 |   f/1    |
                        58 | REF | 58 |
                           |          |

(X2) | REF | 58 |              STACK
                           |          |
                   (Y1) 82 | REF | 82 |
                           |          |
```
これによりスタックからヒープへの参照が維持され、「WAMバインディングルール2」が尊重される


　
#### [変数分類の再検討]
NOTE：実はparmanent変数(PV)とは単に従来のローカル変数（スタック上に確保されたもの）であるにすぎない


David H. D. Warrenによれば
- まず、すべての変数をPVとして考えよう
- 次に、既に前のデータで初期化されているもの、ヒープ上に存在する構造体の一部であるもの、LCOのためにグローバル化する必要があるもの・・・をTV(temporary変数)と呼び、スタック・スペースを節約しよう

　
##### Warren の変数分類：
- temporary変数とは、複数のボディ・ゴール（ヘッドは最初のボディ・ゴールの一部と数える）に出現せず、最初にヘッド、構造体、または最後のゴールに出現する変数のことである
- parmanent変数とは、temporaryでない変数のことである

NOTE:
- 我々の分類でも Warren の分類でも、複数のボディゴールに出現する変数はparmanent変数(PV)である
- しかし Warren の分類では、PVは1つのボディゴールにのみ発生する場合でも起こり得ることになる

例えば以下の場合、我々の定義によると X は TV である：
```
a　:-　b(X,X), c.
```
しかし Warren の分類では PV となる

　
##### 問題：
ウォーレンの変数分類は、実行時の安全チェックをしたとしても、環境トリミングとの整合性がとれない

以下において、もしも X が PV ならば：
```
a　:-　b(X,X), c.
```

これは、以下のようにコンパイルされる；
```
a/0 : allocate               % a :-
      put_variable Y,A1      %     b(X,
      put_unsafe_value Y1,A2 %         X
      call b/2,0             %          ),
      deallocate             %     c
      execute c/0            %      .
```
これは安全でないコードである
- Y1 は、STACKにアロケートされている
- A1 は、Y1の内容をセットされている
- Y1 は、unsafe であり、グローバライズされなければならない:
  Y1 と A2 を、新しいヒープ・セルへと参照するようにセットする
- Y1 は 環境刈込(ET)によって破棄される
- call b/2 で用いる A1 は、未だに破棄されたスロットを参照している！

##### 解決策：
そのようなPVの環境刈込(ET)の実行は、次の call まで遅延させる
```
a :- b(X,X),c. 刈込の遅延対策後

a/0 : allocate           % a :-
      put_variable Y1,A1 %      b(X,
      put_value Y1,A2    %          X
      call b/2,1         %           ),
      deallocate         %      c
      execute c/0        %       .
```
すなわち、Y1は b/2 の実行が完了するまで環境に保持され、その後破棄される

　
#### [インデキシング]
節の選択処理を高速化するために、WAMは最初の引数をインデックスキーとして使用する

NOTE: プロシージャの定義において、先頭に変数キーを持つ節は選択処理のボトルネックとなる
⇨ プロシージャ p は、一連の節によって定義されている
```
C1,...,Cn
```
また、これらは、一連のサブシーケンスにより分割されている
```
S1,...,Sm
```
ここで各 Si は
- 変数キーを持つ単一節であるであるか、
- キーが変数ではない連続する節の最大のサブシーケンスであるか、のどちらかである

```
S1
    call(X or Y) :- call(X).
    call(trace) :- trace.
    call(X or Y) :- call(Y).
    call(notrace) :- notrace.
    call(nl) :- nl.

S2
    call(X) :- buildin(X).


S3
    call(X) :- extern(X).


S4
    call(call(X)) :- call(X).
    call(repeat).
    call(repeat) :- call(repeat).
    call(true).
```
　

定義が S1,...,Sm に分割された手続き p のためのコンパイルスキーム(ここで m>1 である)：
```
p  : try_me_else S2
     code for subsequence S1
S2 : retry_me_else S3
     code for subsequence S2
               :
Sm : trust_me
     code for subsequence Sm

(ここで retry_me_else は m > 2 の場合に限る)
```
なお m = 1の場合は、上記の対応は不要であり、単一のサブシーケンスのチャンクに必要なコードだけに翻訳される
縮退したサブシーケンス（すなわち、変数キーが１つだけの節）の部分の翻訳は通常通りである。
```
call/1 : try_me_else S2      %
         indexed code for S1 %
S2     : retry_me_else S3    %  call(X)
         execute builtin/1   %          :- builtin(X).
S3     : retry_me_else S4    %  call(X)
         execute extern/1    %          :- extern(X).
S4     : trust_me            %
         indexed code for S4 %
```

　
#### [縮退しないサブシーケンスのインデキシング]
一般的なインデキシングのコードパターン：
```
第1レベルインデキシング
第2レベルインデキシング
第3レベルインデキシング
節をサブシーケンスの順に並べたコード
```
ここで
- 第2レベルと第3レベルは、サブシーケンスに どのような種類のキー が いくつ存在するか によってのみ要不要が判断される
- これらは 縮退時には必要とされない
- 以下のディスパッチ・コードは、通常の逐次選択制御の構築である

第1レベルのディスパッチは、deref(A1)があるか否かによって、
制御を節の（おそらくvoidな）まとまりにジャンプさせる：
- 変数

　　　変数のコードのまとまりは、そのサブシーケンスの逐次探索に完全に対応する（従って、決して無効にはならない）
- 定数

　　　定数のコードのまとまりは、定数どうしの第2レベル・ディスパッチに対応する
- リスト（空でない）

　　　リストのコードのまとまりに対応する：

　　　- リストのキーを伴う単一の節にリンクするか、

　　　- さもなければ、キーがリストである部分節のすべての節のリンクドリストにリンクする

- 構造体

　　　構造体のコードのまとまりは、構造体どうしのの第2レベルのディスパッチに対応する

複数の節を持つ定数(または構造体)については、第3レベルのまとまりが、これらの節のリンクドリストに対応する可能性がある(リストの第2レベルと同じように)
```
第1レベルインデキシング(for S1)
第2レベルインデキシング(for S1)
第3レベルインデキシング(for S1)

S11 : try_me_else S12
      code for 'call(X or Y) :- call(X).'
S12 : retry_me_else S13
      code for 'call(trace) :- trace.'
S13 : retry_me_else S14
      code for 'call(X or Y) :- call(Y).'
S14 : retry_me_else S15
      code for 'call(notrace) :- notrace.'
S15 : trust_me
      code for 'call(nl) :- nl.'
```

　
#### [インデキシング命令]

第1レベルのディスパッチング：
- switch_on_term V,C,L,S

　deref(A1)の結果がそれぞれ、変数、定数、空でないリスト、構造体のどれであるかによって、
V、C、L、Sとラベル付けされた命令にそれぞれジャンプする

　
第2レベルのディスパッチング： N個の異なるシンボルに対して
- switch_on_constant N,T

　(Tは {ci: Lci}形式のハッシュテーブルである(i=1〜N))

　もしderef(A1)=ciなら、Lciとラベル付された命令にジャンプするか、
さもなければバックトラックする
- switch_on_structure N,T

　(Tは {si: Lsi}形式のハッシュテーブルである(i=1〜N))

　もしderef(A1)=siなら、Lsiとラベル付された命令にジャンプするか、
さもなければバックトラックする

　
#### 第3レベルインデキシング：
以下を使用して キーがリスト、または同じ定数や構造体である、複数の（必ずしも連続しない）
節のシーケンスをスレッドにまとめる：
- try L,
- retry L,
- trust L.

これらはそれぞれ、try_me_else L、retry_me_else L、trust_meと同じであるが、ラベルLにジャンプし、次の命令を選択ポイントの次の節の選択肢として保存する点が異なる（もちろん、trustを除く）

NOTE: リストに対する第2レベルは、リスト構造に対する第3レベルのインデックスであり、第2レベルは「WAM原則3」（第4章[最適化]の冒頭で掲載された３つめの原則）の精神に基づきリストの特別な処理を施すことによってスキップされる


```
indexing code for subsequence S1

      switch_on_term S11,C1,fail,F1           %  1st level dispatch for S1
C1  : switch_on_constant 3,{ trace   : S1b,   %  2nd level for constants
                             notrace : S1d,
                             nl      : S1e }
F1  : switch_on_structure 1,{ or/2 : F11 }    %  2nd level for structures
F11 : try S1a                                 %  3rd level for or/2
      trust S1c                               %

S11 : try_me_else S12                         %  call
S1a : get_structure or/2,A1                   %      (or
      unify_variable A1                       %         (X,
      unify_void 1                            %            Y))
      execute call/1                          %       :- call(X).

S12 : retry_me_else S13                       %  call
S1b : get_constant trace,A1                   %      (trace)
      execute trace/0                         %       :- trace.

S13 : retry_me_else S14                       %  call
S1c : get_structure or/2,A1                   %      (or
      unify_void 1                            %         (X,
      unify_variable A1                       %            Y))
      execute call/1                          %        :- call(Y).

S14 : retry_me_else S15                       %  call
S1d : get_constant notrace,A1                 %      (notrace)
      execute notrace/0                       %        :- notrace.

S15 : trust_me                                %  call
S1e : get_constant nl,A1                      %      (nl)
      execute nl/0                            %       :- nl.
```


```
indexing code for subsequence S4

S4     switch_on_term S41,C4,fail,F4           %  1st level dispatch for S4
C4   : switch_on_constant 3,{ repeat: C41,     %  2nd level for constants
                              true  : S4d }
F4   : switch_on_structure 1,{ call/1 : S41 }  %  2nd level for structures
C41  : try S4b                                 %  3rd level for 'repeat'
       trust S4c                               %

S41  : try_me_else S42                         %  call
S4a  : get_structure call/1,A1                 %      (call
       unify_variable A1                       %           (X))
       execute call/1                          %       :- call(X).

S42  : retry_me_else S43                       %  call
S4b  : get_constant repeat,A1                  %      (repeat)
       proceed                                 %              .

S43  : retry_me_else S44                       %  call
S4c  : get_constant repeat,A1                  %      (repeat)
       put_constant repeat,A1                  %       :- call(repeat)
       execute call/1                          %                      .
S44  : trust_me                                %  call
S4d  : get_constant true,A1                    %      (true)
       proceed                                 %            .
```
conc([],L,L).

conc([H|T],L,[H|R]) :- conc(T,L,R).
```
Encoding of conc/3

conc/3 : switch_on_term C1a,C1,C2,fail  %

C1a    : try_me_else C2a                %  conc
C1     : get_constant [],A1             %      ([],
         get_value A2,A3                %          L,L)
         proceed                        %              .
C2a    : trust_me                       %  conc
C2     : get_list A1                    %      ([
         unify_variable X4              %        H|
         unify_variable A1              %          T],L,
         get_list A3                    %               [
         unify_value X4                 %                H|
         unify_variable A3              %                  R])
         execute conc/3                 %      :- conc(T,L,R).
```

もしも conc/3 がインスタンス化された第1引数と共に呼び出されたときは、
そのために選択ポイントフレームを用意する必要性はない

実際、選択処理の高速化に付随して、インデックス作成にはセレンディピティ（偶然の出会い）的な大きなメリットがある：
- これにより、選択点フレームの作成と操作が大幅に軽減される
- 無駄な環境保護を省略できる
- LCOとETの効果を増幅させる

　
#### [カット]
#### ! :
成功すると、この手続きに代わる可能性のある他のいかなる選択肢も、
先行するボディ・ゴールから生じる他のいかなる選択肢も忘却する

つまり、この手順を呼び出す直前に現在の選択点の後に作られた選択点はすべて破棄する

#### 【Backtrack Cut Register: BC】

　　BCは、カットした箇所をバックトラックで戻る際に チョイス・ポイントを保持する。

BCには、手続き呼び出しが行われた時点で、最新のチョイス・ポイントのアドレスが保持されていなければならない：

⇨ 現在の B に対して BC の値をセットすることで、call や execute の挙動を変更する

⇨ cut により B を BC の値にリセットすることになる

(NOTE: BC は、チョイス・ポイントの一部として保存され、バックトラック時に復元されなければならない)

cutには２種類ある：
- 浅い（あるいはネック）カット
```
h :- !,b1,...,bn.
```
- ディープカット
```
h :- ...,bi,!,...,bn. (1 ≦ i ≦ n)
```


　
### ネックカット
- neck_cut
Bに続くすべて（実際には1つまたは2つの）チョイス・ポイントを破棄する
`(つまり B ← BC, HB ← B.H)`

```
例えば
        a :- !,b.

は、以下のようにコンパイルされる

        neck_cut
        execute b/0
```
　
### ディープカット
- get_level Yn

　　allocate 後直ちに、Ynを現在のBCにセットする
- cut Yn

　　Ynで示された点以降のチョイス・ポイントは（もしあれば）すべて破棄し、

　　なおかつ、トレイルからその時点までの新たな無条件バインディングを破棄する

```
例えば
        a :- b,!,c.

は、以下のようにコンパイルされる

        allocate
        get_level Y1
        call b/0,1
        cut Y1
        deallocate
        execute c/0
```
